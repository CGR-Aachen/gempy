
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>DataManagement &#8212; GemPy beta documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for DataManagement</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This file is part of gempy.</span>

<span class="sd">    gempy is free software: you can redistribute it and/or modify</span>
<span class="sd">    it under the terms of the GNU General Public License as published by</span>
<span class="sd">    the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">    (at your option) any later version.</span>

<span class="sd">    gempy is distributed in the hope that it will be useful,</span>
<span class="sd">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">    GNU General Public License for more details.</span>

<span class="sd">    You should have received a copy of the GNU General Public License</span>
<span class="sd">    along with gempy.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">path</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># This is for sphenix to find the packages</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span> <span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span> <span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pn</span>
<span class="kn">from</span> <span class="nn">gempy</span> <span class="k">import</span> <span class="n">theanograf</span>
<span class="kn">import</span> <span class="nn">theano</span>

<span class="n">pn</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">chained_assignment</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1">#</span>


<div class="viewcode-block" id="InputData"><a class="viewcode-back" href="../code.html#DataManagement.InputData">[docs]</a><span class="k">class</span> <span class="nc">InputData</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to import the raw data of the model and set data classifications into formations and series.</span>
<span class="sd">    This objects will contain the main information of the model.</span>

<span class="sd">    Args:</span>
<span class="sd">        extent (list):  [x_min, x_max, y_min, y_max, z_min, z_max]</span>
<span class="sd">        Resolution ((Optional[list])): [nx, ny, nz]. Defaults to 50</span>
<span class="sd">        path_i: Path to the data bases of interfaces. Default os.getcwd(),</span>
<span class="sd">        path_f: Path to the data bases of foliations. Default os.getcwd()</span>

<span class="sd">    Attributes:</span>
<span class="sd">        extent(list):  [x_min, x_max, y_min, y_max, z_min, z_max]</span>
<span class="sd">        resolution ((Optional[list])): [nx, ny, nz]</span>
<span class="sd">        Foliations(pandas.core.frame.DataFrame): Pandas data frame with the foliations data</span>
<span class="sd">        Interfaces(pandas.core.frame.DataFrame): Pandas data frame with the interfaces data</span>
<span class="sd">        series(pandas.core.frame.DataFrame): Pandas data frame which contains every formation within each series</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">extent</span><span class="p">,</span>
                 <span class="n">resolution</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
                 <span class="n">path_i</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path_f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># Set extent and resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>

        <span class="c1"># Init number of faults</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_faults</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># TODO choose the default source of data. So far only csv</span>
        <span class="c1"># Create the pandas dataframes</span>

        <span class="c1"># if we dont read a csv we create an empty dataframe with the columns that have to be filled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;formation&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">,</span> <span class="s1">&#39;X_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Z_std&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;dip_std&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth_std&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;X_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Z_std&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">path_f</span> <span class="ow">or</span> <span class="n">path_i</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">import_data_csv</span><span class="p">(</span><span class="n">path_i</span><span class="o">=</span><span class="n">path_i</span><span class="p">,</span> <span class="n">path_f</span><span class="o">=</span><span class="n">path_f</span><span class="p">)</span>

        <span class="c1"># DEP-</span>
        <span class="c1"># self._set_formations()</span>

        <span class="c1"># If not provided set default series</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_series</span><span class="p">()</span>
        <span class="c1"># DEP- self.set_formation_number()</span>

        <span class="c1"># Compute gradients given azimuth and dips to plot data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_gradient</span><span class="p">()</span>

        <span class="c1"># Create default grid object. TODO: (Is this necessary now?)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid_type</span><span class="o">=</span><span class="s2">&quot;regular_3D&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span>
        <span class="c1"># DEP</span>
        <span class="c1">#self.geo_data_type = &#39;InputData&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">potential_at_interfaces</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fault_relation</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="InputData.set_fault_relation_matrix"><a class="viewcode-back" href="../code.html#DataManagement.InputData.set_fault_relation_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">set_fault_relation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel_matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to set the faults that offset a given sequence and therefore also another fault</span>
<span class="sd">        Args:</span>
<span class="sd">            rel_matrix (numpy.array): 2D Boolean array with the logic. Rows affect (offset) columns</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fault_relation</span> <span class="o">=</span> <span class="n">rel_matrix</span></div>

<div class="viewcode-block" id="InputData.import_data_csv"><a class="viewcode-back" href="../code.html#DataManagement.InputData.import_data_csv">[docs]</a>    <span class="k">def</span> <span class="nf">import_data_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_i</span><span class="p">,</span> <span class="n">path_f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to import interfaces and foliations from csv. The format is the same as the export 3D model data of</span>
<span class="sd">        GeoModeller (check in the input data folder for an example).</span>
<span class="sd">        Args:</span>
<span class="sd">            path_i (str): path to the csv table</span>
<span class="sd">            path_f (str): path to the csv table</span>
<span class="sd">            **kwargs: kwargs of Pandas load_csv</span>

<span class="sd">        Attributes:</span>
<span class="sd">            Foliations(pandas.core.frame.DataFrame): Pandas data frame with the foliations data</span>
<span class="sd">            Interfaces(pandas.core.frame.DataFrame): Pandas data frame with the interfaces data</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">path_f</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data_csv</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;foliations&quot;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path_f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> \
                <span class="s2">&quot;One or more columns do not match with the expected values &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">path_i</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data_csv</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;interfaces&quot;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path_i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> \
                <span class="s2">&quot;One or more columns do not match with the expected values &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.get_formations"><a class="viewcode-back" href="../code.html#DataManagement.InputData.get_formations">[docs]</a>    <span class="k">def</span> <span class="nf">get_formations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">             pandas.core.frame.DataFrame: Returns a list of formations</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span></div>

<div class="viewcode-block" id="InputData.calculate_gradient"><a class="viewcode-back" href="../code.html#DataManagement.InputData.calculate_gradient">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the gradient vector of module 1 given dip and azimuth to be able to plot the foliations</span>

<span class="sd">        Attributes:</span>
<span class="sd">            foliations: extra columns with components xyz of the unity vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;G_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;dip&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)))</span> <span class="o">*</span> \
                                 <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;azimuth&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)))</span> <span class="o">*</span> \
                                 <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;polarity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;G_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;dip&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)))</span> <span class="o">*</span> \
                                 <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;azimuth&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)))</span> <span class="o">*</span>\
                                 <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;polarity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;G_z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;dip&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)))</span> <span class="o">*</span>\
                                 <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;polarity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.calculate_orientations"><a class="viewcode-back" href="../code.html#DataManagement.InputData.calculate_orientations">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_orientations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and update the orientation data (azimuth and dip) from gradients in the data frame.</span>
<span class="sd">        :return: automatically updates data frame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;dip&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;G_z&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;polarity&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;azimuth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;G_x&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;G_z&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;polarity&quot;</span><span class="p">]))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;polarity&quot;</span><span class="p">])</span></div>

    <span class="c1"># # DEP?</span>
    <span class="c1"># def create_grid(self, extent=None, resolution=None, grid_type=&quot;regular_3D&quot;, **kwargs):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Method to initialize the class grid. So far is really simple and only has the regular grid type</span>
    <span class="c1">#</span>
    <span class="c1">#     Args:</span>
    <span class="c1">#         grid_type (str): regular_3D or regular_2D (I am not even sure if regular 2D still working)</span>
    <span class="c1">#         **kwargs: Arbitrary keyword arguments.</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns:</span>
    <span class="c1">#         self.grid(GeMpy_core.grid): Object that contain different grids</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#     if not extent:</span>
    <span class="c1">#         extent = self.extent</span>
    <span class="c1">#     if not resolution:</span>
    <span class="c1">#         resolution = self.resolution</span>
    <span class="c1">#</span>
    <span class="c1">#   return self.GridClass(extent, resolution, grid_type=grid_type, **kwargs)</span>

<div class="viewcode-block" id="InputData.set_grid"><a class="viewcode-back" href="../code.html#DataManagement.InputData.set_grid">[docs]</a>    <span class="k">def</span> <span class="nf">set_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid_type</span><span class="o">=</span><span class="s2">&quot;regular_3D&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to initialize the class new_grid. So far is really simple and only has the regular new_grid type</span>

<span class="sd">        Args:</span>
<span class="sd">            grid_type (str): regular_3D or regular_2D (I am not even sure if regular 2D still working)</span>
<span class="sd">            **kwargs: Arbitrary keyword arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            self.new_grid(GeMpy_core.new_grid): Object that contain different grids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">new_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;The shape of new grid must be (n,3) where n is&#39;</span> \
                                                                        <span class="s1">&#39;the number of points of the grid&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">new_grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">extent</span><span class="p">:</span>
                <span class="n">extent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">resolution</span><span class="p">:</span>
                <span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span>

            <span class="k">return</span> <span class="n">GridClass</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">grid_type</span><span class="o">=</span><span class="n">grid_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.data_to_pickle"><a class="viewcode-back" href="../code.html#DataManagement.InputData.data_to_pickle">[docs]</a>    <span class="k">def</span> <span class="nf">data_to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save InputData object to a python pickle (serialization of python). Be aware that if the dependencies</span>
<span class="sd">        versions used to export and import the pickle differ it may give problems</span>
<span class="sd">        Args:</span>
<span class="sd">            path (str): path where save the pickle</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;./geo_data&#39;</span>
        <span class="kn">import</span> <span class="nn">pickle</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="o">+</span><span class="s1">&#39;.pickle&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1"># Pickle the &#39;data&#39; dictionary using the highest protocol available.</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.get_data"><a class="viewcode-back" href="../code.html#DataManagement.InputData.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itype</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that returns the interfaces and foliations pandas Dataframes. Can return both at the same time or only</span>
<span class="sd">        one of the two</span>
<span class="sd">        Args:</span>
<span class="sd">            itype: input data type, either &#39;foliations&#39;, &#39;interfaces&#39; or &#39;all&#39; for both.</span>
<span class="sd">            verbosity (int): Number of properties shown</span>
<span class="sd">        Returns:</span>
<span class="sd">            pandas.core.frame.DataFrame: Data frame with the raw data</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pn</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;object&#39;</span>

        <span class="k">if</span> <span class="n">verbosity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">show_par_f</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">]</span>
            <span class="n">show_par_i</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">show_par_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">columns</span>
            <span class="n">show_par_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">columns</span>

        <span class="k">if</span> <span class="n">numeric</span><span class="p">:</span>
            <span class="n">show_par_f</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;G_x&#39;</span><span class="p">,</span> <span class="s1">&#39;G_y&#39;</span><span class="p">,</span> <span class="s1">&#39;G_z&#39;</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">]</span>
            <span class="n">show_par_i</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float&#39;</span>
        <span class="k">if</span> <span class="n">itype</span> <span class="o">==</span> <span class="s1">&#39;foliations&#39;</span><span class="p">:</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="n">show_par_f</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">itype</span> <span class="o">==</span> <span class="s1">&#39;interfaces&#39;</span><span class="p">:</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="n">show_par_i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">itype</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="n">show_par_i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="n">show_par_f</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)],</span>
                                 <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;interfaces&#39;</span><span class="p">,</span> <span class="s1">&#39;foliations&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;itype has to be: </span><span class="se">\&#39;</span><span class="s1">foliations</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">interfaces</span><span class="se">\&#39;</span><span class="s1">, or </span><span class="se">\&#39;</span><span class="s1">all</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">raw_data</span></div>

<div class="viewcode-block" id="InputData.i_open_set_data"><a class="viewcode-back" href="../code.html#DataManagement.InputData.i_open_set_data">[docs]</a>    <span class="k">def</span> <span class="nf">i_open_set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itype</span><span class="o">=</span><span class="s2">&quot;foliations&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to have interactive pandas tables in jupyter notebooks. The idea is to use this method to interact with</span>
<span class="sd">         the table and i_close_set_data to recompute the parameters that depend on the changes made. I did not find a</span>
<span class="sd">         easier solution than calling two different methods.</span>
<span class="sd">        Args:</span>
<span class="sd">            itype: input data type, either &#39;foliations&#39; or &#39;interfaces&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.core.frame.DataFrame: Data frame with the changed data on real time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">qgrid</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModuleNotFoundError</span><span class="p">(</span><span class="s1">&#39;It is necessary to instal qgrid to have interactive tables&#39;</span><span class="p">)</span>

        <span class="c1"># if the data frame is empty the interactive table is bugged. Therefore I create a default raw when the method</span>
        <span class="c1"># is called</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="s1">&#39;Default Formation&#39;</span><span class="p">,</span> <span class="s1">&#39;Default series&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">])</span><span class="o">.</span>\
                <span class="n">convert_objects</span><span class="p">(</span><span class="n">convert_numeric</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Default Formation&#39;</span><span class="p">,</span> <span class="s1">&#39;Default series&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">convert_objects</span><span class="p">(</span><span class="n">convert_numeric</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Setting some options</span>
        <span class="n">qgrid</span><span class="o">.</span><span class="n">nbinstall</span><span class="p">(</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">qgrid</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="n">show_toolbar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">itype</span> <span class="ow">is</span> <span class="s1">&#39;foliations&#39;</span> <span class="ow">or</span> <span class="n">itype</span> <span class="ow">is</span> <span class="s1">&#39;interfaces&#39;</span><span class="p">,</span> <span class="s1">&#39;itype must be either foliations or interfaces&#39;</span>

        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Remember to call i_close_set_data after the editing.&#39;</span><span class="p">)</span>

        <span class="c1"># We kind of set the show grid to a variable so we can close it afterwards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pandas_frame</span> <span class="o">=</span> <span class="n">qgrid</span><span class="o">.</span><span class="n">show_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">itype</span><span class="o">=</span><span class="n">itype</span><span class="p">))</span></div>

<div class="viewcode-block" id="InputData.i_close_set_data"><a class="viewcode-back" href="../code.html#DataManagement.InputData.i_close_set_data">[docs]</a>    <span class="k">def</span> <span class="nf">i_close_set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to have interactive pandas tables in jupyter notebooks. The idea is to use this method to interact with</span>
<span class="sd">         the table and i_close_set_data to recompute the parameters that depend on the changes made. I did not find a</span>
<span class="sd">         easier solution than calling two different methods.</span>
<span class="sd">        Args:</span>
<span class="sd">            itype: input data type, either &#39;foliations&#39; or &#39;interfaces&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.core.frame.DataFrame: Data frame with the changed data on real time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We close it to guarantee that after this method it is not possible further modifications</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pandas_frame</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Set parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_series</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_gradient</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span></div>

<div class="viewcode-block" id="InputData.load_data_csv"><a class="viewcode-back" href="../code.html#DataManagement.InputData.load_data_csv">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">load_data_csv</span><span class="p">(</span><span class="n">data_type</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to load either interface or foliations data csv files. Normally this is in which GeoModeller exports it</span>

<span class="sd">        Args:</span>
<span class="sd">            data_type (str): &#39;interfaces&#39; or &#39;foliations&#39;</span>
<span class="sd">            path (str): path to the files. Default os.getcwd()</span>
<span class="sd">            **kwargs: Arbitrary keyword arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.core.frame.DataFrame: Data frame with the raw data</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: in case that the columns have a different name specify in pandas which columns are interfaces /</span>
        <span class="c1">#  coordinates, dips and so on.</span>
        <span class="c1"># TODO: use pandas to read any format file not only csv</span>

        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;foliations&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pn</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;interfaces&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pn</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Data type not understood. Try interfaces or foliations&#39;</span><span class="p">)</span></div>

        <span class="c1"># TODO if we load different data the Interpolator parameters must be also updated. Prob call gradients and</span>
        <span class="c1"># series</span>

<div class="viewcode-block" id="InputData.set_interfaces"><a class="viewcode-back" href="../code.html#DataManagement.InputData.set_interfaces">[docs]</a>    <span class="k">def</span> <span class="nf">set_interfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interf_Dataframe</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to change or append a Dataframe to interfaces in place. A equivalent Pandas Dataframe with</span>
<span class="sd">        [&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;formation&#39;] has to be passed.</span>
<span class="sd">        Args:</span>
<span class="sd">            interf_Dataframe: pandas.core.frame.DataFrame with the data</span>
<span class="sd">            append: Bool: if you want to append the new data frame or substitute it</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">interf_Dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> \
            <span class="s2">&quot;One or more columns do not match with the expected values &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">interf_Dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interf_Dataframe</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span> <span class="o">=</span> <span class="n">interf_Dataframe</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_series</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span></div>
        <span class="c1"># self.interfaces.reset_index(drop=True, inplace=True)</span>

<div class="viewcode-block" id="InputData.set_foliations"><a class="viewcode-back" href="../code.html#DataManagement.InputData.set_foliations">[docs]</a>    <span class="k">def</span> <span class="nf">set_foliations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foliat_Dataframe</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Method to change or append a Dataframe to foliations in place.  A equivalent Pandas Dataframe with</span>
<span class="sd">        [&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;dip&#39;, &#39;azimuth&#39;, &#39;polarity&#39;, &#39;formation&#39;] has to be passed.</span>
<span class="sd">          Args:</span>
<span class="sd">              interf_Dataframe: pandas.core.frame.DataFrame with the data</span>
<span class="sd">              append: Bool: if you want to append the new data frame or substitute it</span>
<span class="sd">          &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span>
            <span class="n">foliat_Dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="s2">&quot;One or more columns do not match with the expected values &quot;</span> <span class="o">+</span>\
                                       <span class="nb">str</span><span class="p">(</span><span class="n">foliat_Dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">foliat_Dataframe</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span> <span class="o">=</span> <span class="n">foliat_Dataframe</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_series</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_gradient</span><span class="p">()</span></div>
        <span class="c1">#  self.foliations.reset_index(drop=True, inplace=True)</span>

<div class="viewcode-block" id="InputData.set_series"><a class="viewcode-back" href="../code.html#DataManagement.InputData.set_series">[docs]</a>    <span class="k">def</span> <span class="nf">set_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series_distribution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to define the different series of the project.</span>

<span class="sd">        Args:</span>
<span class="sd">            series_distribution (dict): with the name of the serie as key and the name of the formations as values.</span>
<span class="sd">            order(Optional[list]): order of the series by default takes the dictionary keys which until python 3.6 are</span>
<span class="sd">                random. This is important to set the erosion relations between the different series</span>

<span class="sd">        Returns:</span>
<span class="sd">            self.series: A pandas DataFrame with the series and formations relations</span>
<span class="sd">            self.interfaces: one extra column with the given series</span>
<span class="sd">            self.foliations: one extra column with the given series</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">series_distribution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set to default series</span>
            <span class="c1"># TODO see if some of the formations have already a series and not overwrite</span>
            <span class="n">_series</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Default serie&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()}</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">series_distribution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">,</span> <span class="s2">&quot;series_distribution must be a dictionary, &quot;</span> \
                                                      <span class="s2">&quot;see Docstring for more information&quot;</span>

            <span class="c1"># TODO if self.series exist already maybe we should append instead of overwrite</span>
            <span class="n">_series</span> <span class="o">=</span> <span class="n">series_distribution</span>

        <span class="c1"># The order of the series is very important since it dictates which one is on top of the stratigraphic pile</span>
        <span class="c1"># If it is not given we take the dictionaries keys. NOTICE that until python 3.6 these keys are pretty much</span>
        <span class="c1"># random</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">_series</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># TODO assert len order is equal to len of the dictionary</span>

        <span class="c1"># We create a dataframe with the links</span>
        <span class="c1">#_series = pn.DataFrame(data=_series) #columns=order)</span>
        <span class="n">_series</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">dict</span><span class="p">([</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">pn</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">_series</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">]),</span> <span class="n">columns</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

        <span class="c1"># Now we fill the column series in the interfaces and foliations tables with the correspondant series and</span>
        <span class="c1"># assigned number to the series</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;series&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_series</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;order_series&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_series</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;series&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_series</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;order_series&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_series</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]]</span>

        <span class="c1"># We sort the series altough is only important for the computation (we will do it again just before computing)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;order_series&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;order_series&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Save the dataframe in a property. This is used in the pile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="o">=</span> <span class="n">_series</span>

        <span class="c1"># Set default faults</span>
        <span class="c1"># faults_series = []</span>
        <span class="c1"># for i in self.series.columns:</span>
        <span class="c1">#     if (&#39;fault&#39; in i or &#39;Fault&#39; in i) and &#39;Default&#39; not in i:</span>
        <span class="c1">#         faults_series.append(i)</span>
        <span class="n">faults_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_faults</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_faults</span><span class="p">(</span><span class="n">faults_series</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_indices</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_formation_number</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_fault_relation_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;series&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">(),</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;series&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">())))</span>

        <span class="k">return</span> <span class="n">_series</span></div>

    <span class="k">def</span> <span class="nf">count_faults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Set default faults</span>
        <span class="n">faults_series</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;series&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;fault&#39;</span> <span class="ow">in</span> <span class="n">i</span> <span class="ow">or</span> <span class="s1">&#39;Fault&#39;</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;Default&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">faults_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">faults_series</span>

<div class="viewcode-block" id="InputData.set_faults"><a class="viewcode-back" href="../code.html#DataManagement.InputData.set_faults">[docs]</a>    <span class="k">def</span> <span class="nf">set_faults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a flag to the series that are faults.</span>
<span class="sd">        Args:</span>
<span class="sd">            series_name(list or array_like): Name of the series which are faults</span>
<span class="sd">        &quot;&quot;&quot;</span>
      <span class="c1">#  if not len(series_name) == 0:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;isFault&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;series&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">series_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;isFault&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;series&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">series_name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_faults</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">series_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.order_table"><a class="viewcode-back" href="../code.html#DataManagement.InputData.order_table">[docs]</a>    <span class="k">def</span> <span class="nf">order_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First we sort the dataframes by the series age. Then we set a unique number for every formation and resort</span>
<span class="sd">        the formations. All inplace</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We order the pandas table by series</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">],</span>  <span class="c1"># , &#39;formation number&#39;],</span>
                                                 <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                 <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">],</span>  <span class="c1"># , &#39;formation number&#39;],</span>
                                                 <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                 <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Give formation number</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;formation number&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="ow">not</span> <span class="s1">&#39;formation number&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># print(&#39;I am here&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_formation_number</span><span class="p">()</span>

        <span class="c1"># We order the pandas table by formation (also by series in case something weird happened)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">,</span> <span class="s1">&#39;formation number&#39;</span><span class="p">],</span>
                                                 <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                 <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">,</span> <span class="s1">&#39;formation number&#39;</span><span class="p">],</span>
                                                 <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                 <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Pandas dataframe set an index to every row when the dataframe is created. Sorting the table does not reset</span>
        <span class="c1"># the index. For some of the methods (pn.drop) we have to apply afterwards we need to reset these indeces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Update labels for anotations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_annotations</span><span class="p">()</span></div>

<div class="viewcode-block" id="InputData.set_formation_number"><a class="viewcode-back" href="../code.html#DataManagement.InputData.set_formation_number">[docs]</a>    <span class="k">def</span> <span class="nf">set_formation_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formation_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a unique number to each formation. NOTE: this method is getting deprecated since the user does not need</span>
<span class="sd">        to know it and also now the numbers must be set in the order of the series as well. Therefore this method</span>
<span class="sd">        has been moved to the interpolator class as preprocessing</span>

<span class="sd">        Returns:</span>
<span class="sd">            Column in the interfaces and foliations dataframes</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">if</span> <span class="n">formation_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">formation_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">formation_order</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;Some of the formations given are not in &#39;</span>\
                                                                             <span class="s1">&#39;the formations data frame. Check misspells&#39;</span>\
                                                                             <span class="s1">&#39;and that you include the name of the faults!!!&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ip_addresses</span> <span class="o">=</span> <span class="n">formation_order</span>
            <span class="n">ip_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ip_addresses</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ip_addresses</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;formation number&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ip_dict</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;formation number&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;formation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ip_dict</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">set_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">point_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;formation number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span>
        <span class="n">point_l</span> <span class="o">=</span> <span class="p">[</span><span class="sa">r</span><span class="s1">&#39;${\bf</span><span class="si">{x}</span><span class="s1">}_{\alpha \,{\bf{&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;}},&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;}$&#39;</span>
                   <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">point_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">])]</span>

        <span class="n">foliation_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;formation number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span>
        <span class="n">foli_l</span> <span class="o">=</span> <span class="p">[</span><span class="sa">r</span><span class="s1">&#39;${\bf</span><span class="si">{x}</span><span class="s1">}_{\beta \,{\bf{&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;}},&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;}$&#39;</span>
                   <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">foliation_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">])]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;annotations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">point_l</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;annotations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">foli_l</span>

<div class="viewcode-block" id="InputData.reset_indices"><a class="viewcode-back" href="../code.html#DataManagement.InputData.reset_indices">[docs]</a>    <span class="k">def</span> <span class="nf">reset_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets dataframe indices for foliations and interfaces.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.interface_modify"><a class="viewcode-back" href="../code.html#DataManagement.InputData.interface_modify">[docs]</a>    <span class="k">def</span> <span class="nf">interface_modify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allows modification of the x,y and/or z-coordinates of an interface at specified dataframe index.</span>
<span class="sd">        Args:</span>
<span class="sd">            index: dataframe index of the foliation point</span>
<span class="sd">            **kwargs: X, Y, Z (int or float)</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="InputData.interface_add"><a class="viewcode-back" href="../code.html#DataManagement.InputData.interface_add">[docs]</a>    <span class="k">def</span> <span class="nf">interface_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds interface to dataframe.</span>
<span class="sd">        Args:</span>
<span class="sd">            **kwargs: X, Y, Z, formation, labels, order_series, series</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;series&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_series</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span></div>

<div class="viewcode-block" id="InputData.interface_drop"><a class="viewcode-back" href="../code.html#DataManagement.InputData.interface_drop">[docs]</a>    <span class="k">def</span> <span class="nf">interface_drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drops interface from dataframe identified by index</span>
<span class="sd">        Args:</span>
<span class="sd">            index: dataframe index</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.foliation_modify"><a class="viewcode-back" href="../code.html#DataManagement.InputData.foliation_modify">[docs]</a>    <span class="k">def</span> <span class="nf">foliation_modify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">recalculate_gradient</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">recalculate_orientations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allows modification of foliation data at specified dataframe index.</span>
<span class="sd">        Args:</span>
<span class="sd">            index: dataframe index of the foliation point</span>
<span class="sd">            **kwargs: G_x, G_y, G_z, X, Y, Z, azimuth, dip, formation, labels, order_series, polarity</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">recalculate_gradient</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_gradient</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">recalculate_orientations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_orientations</span><span class="p">()</span></div>

<div class="viewcode-block" id="InputData.foliation_add"><a class="viewcode-back" href="../code.html#DataManagement.InputData.foliation_add">[docs]</a>    <span class="k">def</span> <span class="nf">foliation_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds foliation to dataframe.</span>
<span class="sd">        Args:</span>
<span class="sd">            **kwargs: G_x, G_y, G_z, X, Y, Z, azimuth, dip, formation, labels, order_series, polarity, series</span>

<span class="sd">        Returns: Nothing</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_gradient</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_series</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span></div>

<div class="viewcode-block" id="InputData.foliations_drop"><a class="viewcode-back" href="../code.html#DataManagement.InputData.foliations_drop">[docs]</a>    <span class="k">def</span> <span class="nf">foliations_drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drops foliation from dataframe identified by index</span>
<span class="sd">        Args:</span>
<span class="sd">            index: dataframe index</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.get_formation_number"><a class="viewcode-back" href="../code.html#DataManagement.InputData.get_formation_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_formation_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get a dictionary with the key the name of the formation and the value their number</span>

<span class="sd">            Returns:</span>
<span class="sd">                dict: key the name of the formation and the value their number</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="n">pn_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;formation number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">formation</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">ip_addresses</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pn_series</span><span class="p">):</span>
            <span class="n">ip_addresses</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ip_addresses</span><span class="p">[</span><span class="s1">&#39;DefaultBasement&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">ip_addresses</span></div>

    <span class="c1"># # TODO think where this function should go</span>
    <span class="k">def</span> <span class="nf">_read_vox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        read vox from geomodeller and transform it to gempy format</span>
<span class="sd">        Returns:</span>
<span class="sd">            numpy.array: block model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">geo_res</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="n">geo_res</span> <span class="o">=</span> <span class="n">geo_res</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">9</span><span class="p">:]</span>

        <span class="c1">#ip_addresses = geo_res[&#39;nx 50&#39;].unique()  # geo_data.interfaces[&quot;formation&quot;].unique()</span>
        <span class="n">ip_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_formation_number</span><span class="p">()</span>

        <span class="n">geo_res_num</span> <span class="o">=</span> <span class="n">geo_res</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ip_dict</span><span class="p">)</span>
        <span class="n">block_geomodeller</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">geo_res_num</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">block_geomodeller</span>

    <span class="k">def</span> <span class="nf">set_triangle_foliations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># next we need to iterate over every unique triangle id to create a foliation from each triplet</span>
        <span class="c1"># of points and assign the same triange_id to it</span>
        <span class="n">tri_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;triangle_id&quot;</span><span class="p">])</span>

        <span class="c1"># check if column in foliations too, else create it</span>
        <span class="k">if</span> <span class="s2">&quot;triangle_id&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;triangle_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;NaN&quot;</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Setting triangle_id column in geo_data.foliations.&quot;</span><span class="p">)</span>

        <span class="c1"># loop over all triangle_id&#39;s</span>
        <span class="k">for</span> <span class="n">tri_id</span> <span class="ow">in</span> <span class="n">tri_ids</span><span class="p">[</span><span class="n">tri_ids</span> <span class="o">!=</span> <span class="s2">&quot;NaN&quot;</span><span class="p">]:</span>
            <span class="c1"># get the three points dataframe</span>
            <span class="n">_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;triangle_id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">tri_id</span>

            <span class="c1"># check if triangle foliation value already exists</span>
            <span class="k">if</span> <span class="n">tri_id</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;triangle_id&quot;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;triangle_id already in geo_data.foliations - skipping it.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>  <span class="c1"># if yes, continue with the next iteration not not double append</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tri_id: &quot;</span><span class="o">+</span><span class="n">tri_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="n">_filter</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># get points as [x,y,z]</span>
                <span class="n">_points</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">interf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="n">_filter</span><span class="p">]</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="n">_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">interf</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">],</span> <span class="n">interf</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">],</span> <span class="n">interf</span><span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]])</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;3 points xyz:&quot;</span><span class="p">,</span><span class="n">_points</span><span class="p">)</span>

                <span class="c1"># get plane normal from three points</span>
                <span class="n">_normal</span> <span class="o">=</span> <span class="n">_get_plane_normal</span><span class="p">(</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_points</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                <span class="c1"># get dip and azimuth</span>
                <span class="n">_dip</span><span class="p">,</span> <span class="n">_az</span> <span class="o">=</span> <span class="n">_get_dip</span><span class="p">(</span><span class="n">_normal</span><span class="p">)</span>
                <span class="c1"># now get centroid of three points</span>
                <span class="n">_centroid</span> <span class="o">=</span> <span class="n">_get_centroid</span><span class="p">(</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_points</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="c1"># set polarity according to overturned or not</span>
                <span class="k">if</span> <span class="o">-</span><span class="mi">90</span> <span class="o">&lt;</span> <span class="n">_dip</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                    <span class="n">_pol</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_pol</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="n">_fmt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="n">_filter</span><span class="p">][</span><span class="s2">&quot;formation&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># _series = np.unique(self.interfaces[_filter][&quot;series&quot;])[0]</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;plane normal:&quot;</span><span class="p">,</span> <span class="n">_normal</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dip&quot;</span><span class="p">,</span> <span class="n">_dip</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;az&quot;</span><span class="p">,</span> <span class="n">_az</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;centroid x,y,z:&quot;</span><span class="p">,</span> <span class="n">_centroid</span><span class="p">)</span>

                <span class="n">_f</span> <span class="o">=</span> <span class="p">[</span><span class="n">_centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_centroid</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">_dip</span><span class="p">,</span> <span class="n">_az</span><span class="p">,</span> <span class="n">_pol</span><span class="p">,</span> <span class="n">_fmt</span><span class="p">,</span> <span class="n">tri_id</span><span class="p">]</span>
                <span class="n">_fs</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">_f</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">,</span> <span class="s1">&#39;triangle_id&#39;</span><span class="p">])</span>
                <span class="n">_df</span> <span class="o">=</span> <span class="n">_fs</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_foliations</span><span class="p">(</span><span class="n">_df</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="n">_filter</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;More than three points share the same triangle-id: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                    <span class="n">tri_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;. Only exactly 3 points are supported.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="n">_filter</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Less than three points share the same triangle-id: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                    <span class="n">tri_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;. Only exactly 3 points are supported.&quot;</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">FoliaitionsFromInterfaces</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geo_data</span><span class="p">,</span> <span class="n">group_id</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            geo_data: InputData object</span>
<span class="sd">            group_id: (str) identifier for the data group</span>
<span class="sd">            mode: (str), either &#39;interf_to_fol&#39; or &#39;fol_to_interf&#39;</span>
<span class="sd">            verbose: (bool) adjusts verbosity, default False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span> <span class="o">=</span> <span class="n">geo_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_id</span> <span class="o">=</span> <span class="n">group_id</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="s2">&quot;interf_to_fol&quot;</span><span class="p">:</span>
            <span class="c1"># df bool filter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;group_id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_id</span>
            <span class="c1"># get formation string</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">formation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">][</span><span class="s2">&quot;formation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># df indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interf_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
            <span class="c1"># get point coordinates from df</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interf_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">()</span>
            <span class="c1"># get point cloud centroid and normal vector of plane</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_plane_svd</span><span class="p">()</span>
            <span class="c1"># get dip and azimuth of plane from normal vector</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dip</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dip</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;fol_to_interf&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;group_id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">formation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">][</span><span class="s2">&quot;formation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># get interface indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interf_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;group_id&quot;</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">group_id</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
            <span class="c1"># get interface point coordinates from df</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interf_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">][</span><span class="s2">&quot;G_x&quot;</span><span class="p">],</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">][</span><span class="s2">&quot;G_y&quot;</span><span class="p">],</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">][</span><span class="s2">&quot;G_z&quot;</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">][</span><span class="s2">&quot;X&quot;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">][</span><span class="s2">&quot;Y&quot;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">][</span><span class="s2">&quot;Z&quot;</span><span class="p">]]</span>
            <span class="c1"># modify all Z of interface points belonging to group_id to fit plane</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fol_to_p</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mode must be either &#39;interf_to_fol&#39; or &#39;fol_to_interf&#39;.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fol_to_p</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
        <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;group_id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_id</span><span class="p">]</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="c1"># iterate over each point and recalculate Z, set Z</span>
            <span class="c1"># x, y, z = row[&quot;X&quot;], row[&quot;Y&quot;], row[&quot;Z&quot;]</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span><span class="o">/-</span><span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns n points from geo_data.interfaces matching group_id in np.array shape (n, 3).&quot;&quot;&quot;</span>
        <span class="c1"># TODO: zip</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;group_id&quot;</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">group_id</span><span class="p">]</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">]))</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">]))</span>
            <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_fit_plane_svd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit plane to points using singular value decomposition (svd). Returns point cloud centroid [x,y,z] and</span>
<span class="sd">        normal vector of plane [x,y,z].&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">svd</span>
        <span class="c1"># https://stackoverflow.com/questions/12299540/plane-fitting-to-4-or-more-xyz-points</span>
        <span class="n">ctr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interf_p</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># calculate point cloud centroid [x,y,z]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interf_p</span> <span class="o">-</span> <span class="n">ctr</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># np.cov(x)</span>
        <span class="k">return</span> <span class="n">ctr</span><span class="p">,</span> <span class="n">svd</span><span class="p">(</span><span class="n">m</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_dip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns dip angle and azimuth of normal vector [x,y,z].&quot;&quot;&quot;</span>
        <span class="n">dip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">180.</span>

        <span class="n">azimuth</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">azimuth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">180.</span>
        <span class="c1"># border cases where arctan not defined:</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">azimuth</span> <span class="o">=</span> <span class="mi">90</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">azimuth</span> <span class="o">=</span> <span class="mi">270</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">azimuth</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">180.</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">azimuth</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">180.</span>

        <span class="k">if</span> <span class="o">-</span><span class="mi">90</span> <span class="o">&lt;</span> <span class="n">dip</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
            <span class="n">polarity</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">polarity</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">dip</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">polarity</span>

    <span class="k">def</span> <span class="nf">set_fol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Appends foliation data point for group_id to geo_data.foliations.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;group_id&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;group_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;NaN&quot;</span>
        <span class="n">fol</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">dip</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polarity</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">formation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_id</span><span class="p">]</span>
        <span class="n">fol_series</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">fol</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">,</span> <span class="s1">&#39;group_id&#39;</span><span class="p">])</span>
        <span class="n">fol_df</span> <span class="o">=</span> <span class="n">fol_series</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geo_data</span><span class="o">.</span><span class="n">set_foliations</span><span class="p">(</span><span class="n">fol_df</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_plane_normal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns normal vector of plane defined by points A,B,C as [x,y,z].&quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

    <span class="n">v1</span> <span class="o">=</span> <span class="n">C</span> <span class="o">-</span> <span class="n">A</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">A</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;vector C-A&quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;vector B-A&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_centroid</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns centroid (x,y,z) of three points 3x[x,y,z].&quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">3</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">3</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mi">3</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span>


<div class="viewcode-block" id="GridClass"><a class="viewcode-back" href="../code.html#DataManagement.GridClass">[docs]</a><span class="k">class</span> <span class="nc">GridClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    -DOCS NOT UPDATED- Class with set of functions to generate grids</span>

<span class="sd">    Args:</span>
<span class="sd">        extent (list):  [x_min, x_max, y_min, y_max, z_min, z_max]</span>
<span class="sd">        resolution (list): [nx, ny, nz].</span>
<span class="sd">        grid_type(str): Type of grid. So far only regular 3D is implemented</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">grid_type</span><span class="o">=</span><span class="s2">&quot;regular_3D&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span> <span class="o">=</span> <span class="n">extent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid_res</span> <span class="o">=</span> <span class="n">resolution</span>

        <span class="k">if</span> <span class="n">grid_type</span> <span class="o">==</span> <span class="s2">&quot;regular_3D&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_regular_grid_3d</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Wrong type&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span> <span class="o">=</span> <span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">-</span> <span class="n">extent</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="GridClass.create_regular_grid_3d"><a class="viewcode-back" href="../code.html#DataManagement.GridClass.create_regular_grid_3d">[docs]</a>    <span class="k">def</span> <span class="nf">create_regular_grid_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to create a 3D regular grid where is interpolated</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Unraveled 3D numpy array where every row correspond to the xyz coordinates of a regular grid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_res</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">,</span> <span class="n">g</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="InterpolatorInput"><a class="viewcode-back" href="../code.html#DataManagement.InterpolatorInput">[docs]</a><span class="k">class</span> <span class="nc">InterpolatorInput</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    InterpolatorInput is a class that contains all the preprocessing operations to prepare the data to compute the model.</span>
<span class="sd">    Also is the object that has to be manipulated to vary the data without recompile the modeling function.</span>

<span class="sd">    Args:</span>
<span class="sd">        geo_data(gempy.DataManagement.InputData): All values of a DataManagement object</span>
<span class="sd">        compile_theano (bool): select if the theano function is compiled during the initialization. Default: True</span>
<span class="sd">        compute_all (bool): If true the solution gives back the block model of lithologies, the potential field and</span>
<span class="sd">         the block model of faults. If False only return the block model of lithologies. This may be important to speed</span>
<span class="sd">          up the computation. Default True</span>
<span class="sd">        u_grade (list): grade of the polynomial for the universal part of the Kriging interpolations. The value has to</span>
<span class="sd">        be either 0, 3 or 9 (number of equations) and the length has to be the number of series. By default the value</span>
<span class="sd">        depends on the number of points given as input to try to avoid singular matrix. NOTE: if during the computation</span>
<span class="sd">        of the model a singular matrix is returned try to reduce the u_grade of the series.</span>
<span class="sd">        rescaling_factor (float): rescaling factor of the input data to improve the stability when float32 is used. By</span>
<span class="sd">        defaut the rescaling factor is calculated to obtein values between 0 and 1.</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">         dtype (&#39;str&#39;): Choosing if using float32 or float64. This is important if is intended to use the GPU</span>
<span class="sd">         See Also InterpolatorClass kwargs</span>

<span class="sd">    Attributes:</span>
<span class="sd">        geo_data: Original gempy.DataManagement.InputData object</span>
<span class="sd">        geo_data_res: Rescaled data. It has the same structure has gempy.InputData</span>
<span class="sd">        interpolator: Instance of the gempy.DataManagement.InterpolaorInput.InterpolatorClass. See Also</span>
<span class="sd">         gempy.DataManagement.InterpolaorInput.InterpolatorClass docs</span>
<span class="sd">         th_fn: Theano function which compute the interpolation</span>
<span class="sd">        dtype:  type of float</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geo_data</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;geology&#39;</span><span class="p">,</span> <span class="n">compile_theano</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compute_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">u_grade</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescaling_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO add all options before compilation in here. Basically this is n_faults, n_layers, verbose, dtype, and \</span>
        <span class="c1"># only block or all</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="n">InputData</span><span class="p">),</span> <span class="s1">&#39;You need to pass a InputData object&#39;</span>

        <span class="c1"># Store the original InputData object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geo_data</span> <span class="o">=</span> <span class="n">geo_data</span>

        <span class="c1"># Here we can change the dtype for stability and GPU vs CPU</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span>

        <span class="c1">#self.in_data = self.rescale_data(geo_data, rescaling_factor=rescaling_factor)</span>
        <span class="c1"># Set some parameters. TODO possibly this should go in kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_grade</span> <span class="o">=</span> <span class="n">u_grade</span>

        <span class="c1"># This two properties get set calling rescale data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rescaling_factor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extent_rescaled</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Rescaling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_data</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="n">rescaling_factor</span><span class="o">=</span><span class="n">rescaling_factor</span><span class="p">)</span>

        <span class="c1"># # This are necessary parameters for the visualization package</span>
        <span class="c1">#self.resolution = self.geo_data.resolution</span>
        <span class="c1">#self.extent = self.extent_rescaled.as_matrix()</span>

        <span class="c1"># Creating interpolator class with all the precompilation options</span>
        <span class="c1"># --DEP-- self.interpolator = self.set_interpolator(**kwargs)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">InterpolatorClass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compile_theano</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">th_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compile_th_fn</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">compute_all</span><span class="o">=</span><span class="n">compute_all</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">geophy</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="InterpolatorInput.compile_th_fn"><a class="viewcode-back" href="../code.html#DataManagement.InterpolatorInput.compile_th_fn">[docs]</a>    <span class="k">def</span> <span class="nf">compile_th_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">compute_all</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile the theano function given the input data.</span>
<span class="sd">        Args:</span>
<span class="sd">            compute_all (bool): If true the solution gives back the block model of lithologies, the potential field and</span>
<span class="sd">             the block model of faults. If False only return the block model of lithologies. This may be important to speed</span>
<span class="sd">              up the computation. Default True</span>

<span class="sd">        Returns:</span>
<span class="sd">            theano.function: Compiled function if C or CUDA which computes the interpolation given the input data</span>
<span class="sd">            (XYZ of dips, dip, azimuth, polarity, XYZ ref interfaces, XYZ rest interfaces)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This are the shared parameters and the compilation of the function. This will be hidden as well at some point</span>
        <span class="n">input_data_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">input_parameters_list</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="s1">&#39;geology&#39;</span><span class="p">:</span>
            <span class="c1"># then we compile we have to pass the number of formations that are faults!!</span>
            <span class="n">th_fn</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">input_data_T</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">compute_geological_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">n_faults</span><span class="p">,</span>
                                                                                  <span class="n">compute_all</span><span class="o">=</span><span class="n">compute_all</span><span class="p">),</span>
                                    <span class="n">on_unused_input</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                                    <span class="n">allow_input_downcast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">profile</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="s1">&#39;gravity&#39;</span><span class="p">:</span>
            <span class="c1"># then we compile we have to pass the number of formations that are faults!!</span>
            <span class="n">th_fn</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">input_data_T</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">compute_forward_gravity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">n_faults</span><span class="p">,</span>
                                                                                 <span class="n">compute_all</span><span class="o">=</span><span class="n">compute_all</span><span class="p">),</span>
                                    <span class="n">on_unused_input</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                                    <span class="n">allow_input_downcast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">profile</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Level of Optimization: &#39;</span><span class="p">,</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">optimizer</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Device: &#39;</span><span class="p">,</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Precision: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">th_fn</span></div>

<div class="viewcode-block" id="InterpolatorInput.rescale_data"><a class="viewcode-back" href="../code.html#DataManagement.InterpolatorInput.rescale_data">[docs]</a>    <span class="k">def</span> <span class="nf">rescale_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geo_data</span><span class="p">,</span> <span class="n">rescaling_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rescale the data of a DataManagement object between 0 and 1 due to stability problem of the float32.</span>
<span class="sd">        Args:</span>
<span class="sd">            geo_data: Original gempy.DataManagement.InputData object</span>
<span class="sd">            rescaling_factor(float): factor of the rescaling. Default to maximum distance in one the axis</span>

<span class="sd">        Returns:</span>
<span class="sd">            gempy.DataManagement.InputData: Rescaled data</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO split this function in compute rescaling factor and rescale z</span>

        <span class="c1"># Check which axis is the largest</span>
        <span class="n">max_coord</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">,</span> <span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span>
        <span class="n">min_coord</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">,</span> <span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span>

        <span class="c1"># Compute rescalin factor if not given</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rescaling_factor</span><span class="p">:</span>
            <span class="n">rescaling_factor</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">max_coord</span> <span class="o">-</span> <span class="n">min_coord</span><span class="p">)</span>

        <span class="c1"># Get the centers of every axis</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_coord</span> <span class="o">+</span> <span class="n">min_coord</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># Change the coordinates of interfaces</span>
        <span class="n">new_coord_interfaces</span> <span class="o">=</span> <span class="p">(</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span> <span class="o">-</span>
                                <span class="n">centers</span><span class="p">)</span> <span class="o">/</span> <span class="n">rescaling_factor</span> <span class="o">+</span> <span class="mf">0.5001</span>

        <span class="c1"># Change the coordinates of foliations</span>
        <span class="n">new_coord_foliations</span> <span class="o">=</span> <span class="p">(</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span> <span class="o">-</span>
                                <span class="n">centers</span><span class="p">)</span> <span class="o">/</span> <span class="n">rescaling_factor</span> <span class="o">+</span> <span class="mf">0.5001</span>

        <span class="c1"># Rescaling the std in case of stochastic values</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[[</span><span class="s1">&#39;X_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Z_std&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span>
                                                                    <span class="p">[</span><span class="s1">&#39;X_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Z_std&#39;</span><span class="p">]])</span> <span class="o">/</span> <span class="n">rescaling_factor</span>
            <span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[[</span><span class="s1">&#39;X_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Z_std&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span>
                                                                    <span class="p">[</span><span class="s1">&#39;X_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Z_std&#39;</span><span class="p">]])</span> <span class="o">/</span> <span class="n">rescaling_factor</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Updating properties</span>
        <span class="n">new_coord_extent</span> <span class="o">=</span> <span class="p">(</span><span class="n">geo_data</span><span class="o">.</span><span class="n">extent</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">rescaling_factor</span> <span class="o">+</span> <span class="mf">0.5001</span>

        <span class="n">geo_data_rescaled</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">geo_data</span><span class="p">)</span>
        <span class="n">geo_data_rescaled</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_coord_interfaces</span>
        <span class="n">geo_data_rescaled</span><span class="o">.</span><span class="n">foliations</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_coord_foliations</span>
        <span class="n">geo_data_rescaled</span><span class="o">.</span><span class="n">extent</span> <span class="o">=</span> <span class="n">new_coord_extent</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

        <span class="n">geo_data_rescaled</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">geo_data</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span> <span class="o">-</span> <span class="n">centers</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">())</span> <span class="o">/</span> <span class="n">rescaling_factor</span> <span class="o">+</span> <span class="mf">0.5001</span>

        <span class="c1"># Saving useful values for later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rescaling_factor</span> <span class="o">=</span> <span class="n">rescaling_factor</span>
        <span class="n">geo_data_rescaled</span><span class="o">.</span><span class="n">rescaling_factor</span> <span class="o">=</span> <span class="n">rescaling_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centers</span> <span class="o">=</span> <span class="n">centers</span>
      <span class="c1">#  self.extent_rescaled = new_coord_extent</span>

        <span class="k">return</span> <span class="n">geo_data_rescaled</span></div>

<div class="viewcode-block" id="InterpolatorInput.get_formation_number"><a class="viewcode-back" href="../code.html#DataManagement.InterpolatorInput.get_formation_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_formation_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEP in next version. Get a dictionary with the key the name of the formation and the value their number</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: key the name of the formation and the value their number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pn_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;formation number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">formation</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">ip_addresses</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pn_series</span><span class="p">):</span>
            <span class="n">ip_addresses</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ip_addresses</span><span class="p">[</span><span class="s1">&#39;DefaultBasement&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">ip_addresses</span></div>

    <span class="c1"># --DEP--</span>
    <span class="c1"># def set_interpolator(self, geo_data=None, **kwargs):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Method to initialize the class interpolator. All the constant parameters for the interpolation can be passed</span>
    <span class="c1">#     as args, otherwise they will take the default value (TODO: documentation of the dafault values)</span>
    <span class="c1">#</span>
    <span class="c1">#     Args:</span>
    <span class="c1">#         geo_data: Original gempy.DataManagement.InputData object. If given it rescales it again Default takes the property</span>
    <span class="c1">#</span>
    <span class="c1">#     Keyword Args:</span>
    <span class="c1">#         range_var: Range of the variogram. Default None</span>
    <span class="c1">#         c_o: Covariance at 0. Default None</span>
    <span class="c1">#         nugget_effect: Nugget effect of the gradients. Default 0.01</span>
    <span class="c1">#         u_grade: Grade of the polynomial used in the universal part of the Kriging. Default 2</span>
    <span class="c1">#         rescaling_factor: Magic factor that multiplies the covariances). Default 2</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns:</span>
    <span class="c1">#         self.Interpolator (GeMpy_core.Interpolator): Object to perform the potential field method</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#     if &#39;u_grade&#39; in kwargs:</span>
    <span class="c1">#         compile_theano = True</span>
    <span class="c1">#</span>
    <span class="c1">#     range_var = kwargs.get(&#39;range_var&#39;, None)</span>
    <span class="c1">#</span>
    <span class="c1">#     rescaling_factor = kwargs.get(&#39;rescaling_factor&#39;, None)</span>
    <span class="c1">#</span>
    <span class="c1">#     if geo_data:</span>
    <span class="c1">#         geo_data_in = self.rescale_data(geo_data, rescaling_factor=rescaling_factor)</span>
    <span class="c1">#         self.geo_data_res = geo_data_in</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         geo_data_in = self.geo_data_res</span>
    <span class="c1">#</span>
    <span class="c1">#     # First creation</span>
    <span class="c1">#     if not getattr(self, &#39;interpolator&#39;, None):</span>
    <span class="c1">#         # print(&#39;I am in the setting&#39;)</span>
    <span class="c1">#         interpolator = self.InterpolatorClass(geo_data_in, geo_data_in.grid, **kwargs)</span>
    <span class="c1">#</span>
    <span class="c1">#     # Update</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         print(&#39;I am in update&#39;)</span>
    <span class="c1">#         # I update the data</span>
    <span class="c1">#         self.interpolator._data_scaled = geo_data_in</span>
    <span class="c1">#         self.interpolator._grid_scaled = geo_data_in.grid</span>
    <span class="c1">#         # I order it again just in case. TODO if this still necessary</span>
    <span class="c1">#         self.interpolator.order_table()</span>
    <span class="c1">#</span>
    <span class="c1">#         # Refresh all shared parameters of</span>
    <span class="c1">#         self.interpolator.set_theano_shared_parameteres(range_var=range_var)</span>
    <span class="c1">#         interpolator = None</span>
    <span class="c1">#</span>
    <span class="c1">#     return interpolator</span>

<div class="viewcode-block" id="InterpolatorInput.update_interpolator"><a class="viewcode-back" href="../code.html#DataManagement.InterpolatorInput.update_interpolator">[docs]</a>    <span class="k">def</span> <span class="nf">update_interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geo_data_res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to update the constant parameters of the class interpolator (i.e. theano shared).</span>
<span class="sd">         All the constant parameters for the interpolation can be passed</span>
<span class="sd">        as kwargs, otherwise they will take the default value (TODO: documentation of the dafault values)</span>

<span class="sd">        Args:</span>
<span class="sd">            geo_data_res: Rescaled gempy.DataManagement.InputData object.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">           range_var: Range of the variogram. Default None</span>
<span class="sd">           c_o: Covariance at 0. Default None</span>
<span class="sd">           nugget_effect: Nugget effect of the gradients. Default 0.01</span>
<span class="sd">           u_grade: Grade of the polynomial used in the universal part of the Kriging. Default 2</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">geo_data_res</span><span class="p">:</span>
            <span class="n">geo_data_in</span> <span class="o">=</span> <span class="n">geo_data_res</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span> <span class="o">=</span> <span class="n">geo_data_in</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">geo_data_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span>

        <span class="c1">#  print(&#39;I am in update&#39;)</span>
        <span class="c1"># I update the data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">geo_data_res</span> <span class="o">=</span> <span class="n">geo_data_in</span>
        <span class="c1">#self.interpolator.geo_data_res.grid_res = geo_data_in.grid</span>
        <span class="c1"># I order it again just in case. TODO if this still necessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">set_theano_shared_parameteres</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">data_prep</span><span class="p">()</span></div>

<div class="viewcode-block" id="InterpolatorInput.get_input_data"><a class="viewcode-back" href="../code.html#DataManagement.InterpolatorInput.get_input_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_input_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u_grade</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the theano variables that are input. This are necessary to compile the theano function</span>
<span class="sd">        or a theno op for pymc3</span>
<span class="sd">        Args:</span>
<span class="sd">             u_grade (list): grade of the polynomial for the universal part of the Kriging interpolations. The value has to</span>
<span class="sd">            be either 0, 3 or 9 (number of equations) and the length has to be the number of series. By default the value</span>
<span class="sd">            depends on the number of points given as input to try to avoid singular matrix. NOTE: if during the computation</span>
<span class="sd">            of the model a singular matrix is returned try to reduce the u_grade of the series.</span>

<span class="sd">        Returns:</span>
<span class="sd">            theano.variables: input nodes of the theano graph</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">u_grade</span><span class="p">:</span>
            <span class="n">u_grade</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_grade</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">data_prep</span><span class="p">(</span><span class="n">u_grade</span><span class="o">=</span><span class="n">u_grade</span><span class="p">)</span></div>

    <span class="c1">## =======</span>
    <span class="c1">## Gravity</span>
    <span class="k">def</span> <span class="nf">set_geophysics_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ai_extent</span><span class="p">,</span> <span class="n">ai_resolution</span><span class="p">,</span> <span class="n">ai_z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">range_max</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.GeoPhysics</span> <span class="k">import</span> <span class="n">GeoPhysicsPreprocessing_pro</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geophy</span> <span class="o">=</span> <span class="n">GeoPhysicsPreprocessing_pro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ai_extent</span><span class="p">,</span> <span class="n">ai_resolution</span><span class="p">,</span> <span class="n">ai_z</span><span class="o">=</span><span class="n">ai_z</span><span class="p">,</span> <span class="n">range_max</span><span class="o">=</span><span class="n">range_max</span><span class="p">)</span>

<div class="viewcode-block" id="InterpolatorInput.InterpolatorClass"><a class="viewcode-back" href="../code.html#DataManagement.InterpolatorInput.InterpolatorClass">[docs]</a>    <span class="k">class</span> <span class="nc">InterpolatorClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        -DOCS NOT UPDATED-</span>
<span class="sd">         Class which contain all needed methods to perform potential field implicit modelling in theano.</span>
<span class="sd">         Here there are methods to modify the shared parameters of the theano graph as well as the final</span>
<span class="sd">         preparation of the data from DataFrames to numpy arrays</span>

<span class="sd">        Args:</span>
<span class="sd">             geo_data_res (gempy.DataManagement.InterpolatorInput): Rescaled data. It has the same structure has gempy.InputData</span>
<span class="sd">            grid(gempy.DataManagement.grid): A grid object rescaled. Default takes it from the InterpolatorInput object.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            range_var: Range of the variogram. Default None</span>
<span class="sd">            c_o: Covariance at 0. Default None</span>
<span class="sd">            nugget_effect: Nugget effect of the gradients. Default 0.01</span>
<span class="sd">            u_grade: Grade of the polynomial used in the universal part of the Kriging. Default 2</span>
<span class="sd">            rescaling_factor: Magic factor that multiplies the covariances). Default 2</span>
<span class="sd">            verbose(int): Level of verbosity during the execution of the functions (up to 5). Default 0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geo_data_res</span><span class="p">,</span> <span class="n">grid_res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

            <span class="c1"># verbose is a list of strings. See theanograph</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># -DEP-rescaling_factor = kwargs.get(&#39;rescaling_factor&#39;, None)</span>

            <span class="c1"># Here we can change the dtype for stability and GPU vs CPU</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
            <span class="c1"># Here we change the graph type</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="s1">&#39;geology&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">output</span>

            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">range_var</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;range_var&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Drift grade</span>
            <span class="n">u_grade</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;u_grade&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

            <span class="c1"># We hide the scaled copy of DataManagement object from the user. The scaling happens in gempy what is a</span>
            <span class="c1"># bit weird. Maybe at some point I should bring the function to this module</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span> <span class="o">=</span> <span class="n">geo_data_res</span>

            <span class="c1"># In case someone wants to provide a grid otherwise we extract it from the DataManagement object.</span>
            <span class="c1"># if not grid_res:</span>
            <span class="c1">#     self.grid_res = geo_data_res.grid</span>
            <span class="c1"># else:</span>
            <span class="c1">#     self.grid_res = grid_res</span>

            <span class="c1"># Importing the theano graph. The methods of this object generate different parts of graph.</span>
            <span class="c1"># See theanograf doc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span> <span class="o">=</span> <span class="n">theanograf</span><span class="o">.</span><span class="n">TheanoGraph_pro</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,)</span>

            <span class="c1"># Sorting data in case the user provides it unordered</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span>

            <span class="c1"># Setting theano parameters</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_theano_shared_parameteres</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Extracting data from the pandas dataframe to numpy array in the required form for the theano function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_prep</span><span class="p">(</span><span class="n">u_grade</span><span class="o">=</span><span class="n">u_grade</span><span class="p">)</span>

            <span class="c1"># Avoid crashing my pc</span>
            <span class="kn">import</span> <span class="nn">theano</span>
            <span class="k">if</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">optimizer</span> <span class="o">!=</span> <span class="s1">&#39;fast_run&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">grid_val_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> \
                       <span class="n">np</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">len_series_i</span><span class="o">.</span><span class="n">get_value</span><span class="p">()))</span> <span class="o">&lt;</span> <span class="mf">2e7</span><span class="p">,</span> \
                       <span class="s1">&#39;The grid is too big for the number of potential fields. Reduce the grid or change the&#39;</span> \
                       <span class="s1">&#39;optimization flag to fast run&#39;</span>

<div class="viewcode-block" id="InterpolatorInput.InterpolatorClass.set_formation_number"><a class="viewcode-back" href="../code.html#DataManagement.InterpolatorInput.InterpolatorClass.set_formation_number">[docs]</a>        <span class="k">def</span> <span class="nf">set_formation_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Set a unique number to each formation. NOTE: this method is getting deprecated since the user does not need</span>
<span class="sd">            to know it and also now the numbers must be set in the order of the series as well. Therefore this method</span>
<span class="sd">            has been moved to the interpolator class as preprocessing</span>

<span class="sd">            Returns:</span>
<span class="sd">                Column in the interfaces and foliations dataframes</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ip_addresses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
                <span class="n">ip_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ip_addresses</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ip_addresses</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ip_dict</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;formation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ip_dict</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span></div>

<div class="viewcode-block" id="InterpolatorInput.InterpolatorClass.order_table"><a class="viewcode-back" href="../code.html#DataManagement.InterpolatorInput.InterpolatorClass.order_table">[docs]</a>        <span class="k">def</span> <span class="nf">order_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            First we sort the dataframes by the series age. Then we set a unique number for every formation and resort</span>
<span class="sd">            the formations. All inplace</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># We order the pandas table by series</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">],</span>  <span class="c1"># , &#39;formation number&#39;],</span>
                                                     <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                     <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">],</span>  <span class="c1"># , &#39;formation number&#39;],</span>
                                                     <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                     <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Give formation number</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;formation number&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c1"># print(&#39;I am here&#39;)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_formation_number</span><span class="p">()</span>

            <span class="c1"># We order the pandas table by formation (also by series in case something weird happened)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">,</span> <span class="s1">&#39;formation number&#39;</span><span class="p">],</span>
                                                     <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                     <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">,</span> <span class="s1">&#39;formation number&#39;</span><span class="p">],</span>
                                                     <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                     <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Pandas dataframe set an index to every row when the dataframe is created. Sorting the table does not reset</span>
            <span class="c1"># the index. For some of the methods (pn.drop) we have to apply afterwards we need to reset these indeces</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="InterpolatorInput.InterpolatorClass.data_prep"><a class="viewcode-back" href="../code.html#DataManagement.InterpolatorInput.InterpolatorClass.data_prep">[docs]</a>        <span class="k">def</span> <span class="nf">data_prep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Ideally this method will extract the data from the pandas dataframes to individual numpy arrays to be input</span>
<span class="sd">            of the theano function. However since some of the shared parameters are function of these arrays shape I also</span>
<span class="sd">            set them here</span>
<span class="sd">            Returns:</span>
<span class="sd">                idl (list): List of arrays which are the input for the theano function:</span>
<span class="sd">                    - numpy.array: dips_position</span>
<span class="sd">                    - numpy.array: dip_angles</span>
<span class="sd">                    - numpy.array: azimuth</span>
<span class="sd">                    - numpy.array: polarity</span>
<span class="sd">                    - numpy.array: ref_layer_points</span>
<span class="sd">                    - numpy.array: rest_layer_points</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">u_grade</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;u_grade&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># ==================</span>
            <span class="c1"># Extracting lengths</span>
            <span class="c1"># ==================</span>
            <span class="c1"># Array containing the size of every formation. Interfaces</span>
            <span class="n">len_interfaces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()])</span>

            <span class="c1"># Size of every layer in rests. SHARED (for theano)</span>
            <span class="n">len_rest_form</span> <span class="o">=</span> <span class="p">(</span><span class="n">len_interfaces</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">number_of_points_per_formation_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">len_rest_form</span><span class="p">)</span>

            <span class="c1"># Position of the first point of every layer</span>
            <span class="n">ref_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">len_interfaces</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

            <span class="c1"># Drop the reference points using pandas indeces to get just the rest_layers array</span>
            <span class="n">pandas_rest_layer_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">ref_position</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pandas_rest_layer_points</span> <span class="o">=</span> <span class="n">pandas_rest_layer_points</span>
            <span class="c1"># TODO: do I need this? PYTHON</span>
            <span class="c1"># DEP- because per series the foliations do not belong to a formation but to the whole series</span>
            <span class="c1"># len_foliations = np.asarray(</span>
            <span class="c1">#     [np.sum(self._data_scaled.foliations[&#39;formation number&#39;] == i)</span>
            <span class="c1">#      for i in self._data_scaled.foliations[&#39;formation number&#39;].unique()])</span>

            <span class="c1"># -DEP- I think this was just a kind of print to know what was going on</span>
        <span class="c1">#    self.pandas_rest = pandas_rest_layer_points</span>

            <span class="c1"># Array containing the size of every series. Interfaces.</span>
            <span class="n">len_series_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pandas_rest_layer_points</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pandas_rest_layer_points</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()])</span>

            <span class="c1"># Cumulative length of the series. We add the 0 at the beginning and set the shared value. SHARED</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">len_series_i</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">len_series_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">())</span>

            <span class="c1"># Array containing the size of every series. Foliations.</span>
            <span class="n">len_series_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()])</span>

            <span class="c1"># Cumulative length of the series. We add the 0 at the beginning and set the shared value. SHARED</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">len_series_f</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">len_series_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">())</span>

            <span class="c1"># =========================</span>
            <span class="c1"># Choosing Universal drifts</span>
            <span class="c1"># =========================</span>

            <span class="k">if</span> <span class="n">u_grade</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">u_grade</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">len_series_i</span><span class="p">)</span>
                <span class="c1"># Force the user to choose drift degree 2</span>
                <span class="c1"># u_grade[len_series_i &gt; 12] = 9</span>
                <span class="n">u_grade</span><span class="p">[(</span><span class="n">len_series_i</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">if</span> <span class="s1">&#39;u_grade&#39;</span> <span class="ow">in</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">u_grade</span><span class="p">)</span>
            <span class="c1"># it seems I have to pass list instead array_like that is weird</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">u_grade_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">u_grade</span><span class="p">))</span>

            <span class="c1"># ================</span>
            <span class="c1"># Prepare Matrices</span>
            <span class="c1"># ================</span>
            <span class="c1"># Rest layers matrix # PYTHON VAR</span>
            <span class="n">rest_layer_points</span> <span class="o">=</span> <span class="n">pandas_rest_layer_points</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
          <span class="c1">#  self.rest_layer_points = rest_layer_points</span>
            <span class="c1"># TODO delete</span>
            <span class="c1"># -DEP- Again i was just a check point</span>
            <span class="c1"># self.rest_layer_points = rest_layer_points</span>

            <span class="c1"># TODO: rethink how to do it for pymc</span>
            <span class="c1"># Ref layers matrix #VAR</span>
            <span class="c1"># Calculation of the ref matrix and tile. Iloc works with the row number</span>
            <span class="c1"># Here we extract the reference points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pandas_ref_layer_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ref_position</span><span class="p">]</span><span class="c1">#.apply(</span>
              <span class="c1">#  lambda x: np.repeat(x, len_interfaces - 1))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">len_interfaces</span> <span class="o">=</span> <span class="n">len_interfaces</span>


            <span class="n">pandas_ref_layer_points_rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pandas_ref_layer_points</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">len_interfaces</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">ref_layer_points</span> <span class="o">=</span> <span class="n">pandas_ref_layer_points_rep</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

            <span class="c1"># -DEP- was just a check point</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref_layer_points</span> <span class="o">=</span> <span class="n">ref_layer_points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pandas_ref_layer_points_rep</span> <span class="o">=</span> <span class="n">pandas_ref_layer_points_rep</span>
            <span class="c1"># Check no reference points in rest points (at least in coor x)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> \
                <span class="s1">&#39;A reference point is in the rest list point. Check you do &#39;</span> \
                <span class="s1">&#39;not have duplicated values in your dataframes&#39;</span>

            <span class="c1"># Foliations, this ones I tile them inside theano. PYTHON VAR</span>
            <span class="n">dips_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">foliations</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
            <span class="n">dip_angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;dip&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
            <span class="n">azimuth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;azimuth&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
            <span class="n">polarity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;polarity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

            <span class="c1"># Set all in a list casting them in the chosen dtype</span>
            <span class="n">idl</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">](</span><span class="n">xs</span><span class="p">)</span> <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="p">(</span><span class="n">dips_position</span><span class="p">,</span> <span class="n">dip_angles</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">polarity</span><span class="p">,</span>
                   <span class="n">ref_layer_points</span><span class="p">,</span> <span class="n">rest_layer_points</span><span class="p">)]</span>

            <span class="k">return</span> <span class="n">idl</span></div>

<div class="viewcode-block" id="InterpolatorInput.InterpolatorClass.set_theano_shared_parameteres"><a class="viewcode-back" href="../code.html#DataManagement.InterpolatorInput.InterpolatorClass.set_theano_shared_parameteres">[docs]</a>        <span class="k">def</span> <span class="nf">set_theano_shared_parameteres</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Here we create most of the kriging parameters. The user can pass them as kwargs otherwise we pick the</span>
<span class="sd">            default values from the DataManagement info. The share variables are set in place. All the parameters here</span>
<span class="sd">            are independent of the input data so this function only has to be called if you change the extent or grid or</span>
<span class="sd">            if you want to change one the kriging parameters.</span>

<span class="sd">            Keyword Args:</span>
<span class="sd">                u_grade (int): Drift grade. Default to 2.</span>
<span class="sd">                range_var (float): Range of the variogram. Default 3D diagonal of the extent</span>
<span class="sd">                c_o (float): Covariance at lag 0. Default range_var ** 2 / 14 / 3. See my paper when I write it</span>
<span class="sd">                nugget_effect (flaot): Nugget effect of foliations. Default to 0.01</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Kwargs</span>
            <span class="c1"># --This is DEP because is a condition not a shared-- u_grade = kwargs.get(&#39;u_grade&#39;, 2)</span>
            <span class="n">range_var</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;range_var&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">c_o</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;c_o&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">nugget_effect</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nugget_effect&#39;</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
            <span class="c1"># DEP</span>
           <span class="c1"># compute_all = kwargs.get(&#39;compute_all&#39;, True)</span>

            <span class="c1"># -DEP- Now I rescale the data so we do not need this</span>
            <span class="c1"># rescaling_factor = kwargs.get(&#39;rescaling_factor&#39;, None)</span>

            <span class="c1"># Default range</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">range_var</span><span class="p">:</span>
                <span class="n">range_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>


            <span class="c1"># Default covariance at 0</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">c_o</span><span class="p">:</span>
                <span class="n">c_o</span> <span class="o">=</span> <span class="n">range_var</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">14</span> <span class="o">/</span> <span class="mi">3</span>

            <span class="c1"># Asserting that the drift grade is in this range</span>
           <span class="c1"># assert (0 &lt;= all(u_grade) &lt;= 2)</span>

            <span class="c1"># Creating the drift matrix. TODO find the official name of this matrix?</span>
            <span class="n">_universal_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]))</span>

            <span class="c1"># Setting shared variables</span>
            <span class="c1"># Range</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">a_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">](</span><span class="n">range_var</span><span class="p">))</span>
            <span class="c1"># Covariance at 0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">c_o_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">](</span><span class="n">c_o</span><span class="p">))</span>
            <span class="c1"># Foliations nugget effect</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">nugget_effect_grad_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">](</span><span class="n">nugget_effect</span><span class="p">))</span>

            <span class="c1"># TODO change the drift to the same style I have the faults so I do not need to do this</span>
            <span class="c1"># # Drift grade</span>
            <span class="c1"># if u_grade == 0:</span>
            <span class="c1">#     self.tg.u_grade_T.set_value(u_grade)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     self.tg.u_grade_T.set_value(u_grade)</span>
                <span class="c1"># TODO: To be sure what is the mathematical meaning of this -&gt; It seems that nothing</span>
                <span class="c1"># TODO Deprecated</span>
                <span class="c1"># self.tg.c_resc.set_value(1)</span>

            <span class="c1"># Just grid. I add a small number to avoid problems with the origin point</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">grid_val_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span> <span class="o">+</span> <span class="mf">10e-6</span><span class="p">))</span>
            <span class="c1"># Universal grid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">universal_grid_matrix_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">](</span><span class="n">_universal_matrix</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">))</span>

            <span class="c1"># Initialization of the block model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">final_block</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

            <span class="c1"># Initialization of the boolean array that represent the areas of the block model to be computed in the</span>
            <span class="c1"># following series</span>
            <span class="c1">#self.tg.yet_simulated.set_value(np.ones((_grid_rescaled.grid.shape[0]), dtype=&#39;int&#39;))</span>

            <span class="c1"># Unique number assigned to each lithology</span>
            <span class="c1">#self.tg.n_formation.set_value(np.insert(_data_rescaled.interfaces[&#39;formation number&#39;].unique(),</span>
            <span class="c1">#                                        0, 0)[::-1])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">n_formation</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">))</span>

            <span class="c1"># Number of formations per series. The function is not pretty but the result is quite clear</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;order_series&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">formation</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">final_potential_field_at_formations</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="o">.</span><span class="n">get_value</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                                  <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">final_potential_field_at_faults</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="o">.</span><span class="n">get_value</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                              <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">fault_relation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">fault_relation</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">fault_relation</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fault_rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;series&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">(),</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;series&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()))</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">fault_relation</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">fault_rel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">))</span></div>

        <span class="c1"># TODO change name to weithts!</span>
        <span class="k">def</span> <span class="nf">set_densities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">densities</span><span class="p">):</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>

            <span class="c1">#</span>
            <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">[</span>
                <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1">#dx, dy, dz = self.geo_data_res.grid.dx, self.geo_data_res.grid.dy, self.geo_data_res.grid.dz</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="p">(</span>
                <span class="c1">#(dx * dy * dz) *</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">densities</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">densities</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">set_z_comp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">selected_cells</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">tz</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">tz</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">select</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">selected_cells</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span>

<div class="viewcode-block" id="InterpolatorInput.InterpolatorClass.get_kriging_parameters"><a class="viewcode-back" href="../code.html#DataManagement.InterpolatorInput.InterpolatorClass.get_kriging_parameters">[docs]</a>        <span class="k">def</span> <span class="nf">get_kriging_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Print the kringing parameters</span>
<span class="sd">            Args:</span>
<span class="sd">                verbose (int): if &gt; 0 print all the shape values as well.</span>

<span class="sd">            Returns:</span>
<span class="sd">                None</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># range</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">a_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">a_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_res</span><span class="o">.</span><span class="n">rescaling_factor</span><span class="p">)</span>
            <span class="c1"># Number of drift equations</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of drift equations&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">u_grade_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
            <span class="c1"># Covariance at 0</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Covariance at 0&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">c_o_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
            <span class="c1"># Foliations nugget effect</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Foliations nugget effect&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">nugget_effect_grad_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Input data shapes</span>

                <span class="c1"># Lenght of the interfaces series</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Length of the interfaces series&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">len_series_i</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
                <span class="c1"># Length of the foliations series</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Length of the foliations series&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">len_series_f</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
                <span class="c1"># Number of formation</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of formations&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">n_formation</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
                <span class="c1"># Number of formations per series</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of formations per series&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
                <span class="c1"># Number of points per formation</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of points per formation (rest)&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">number_of_points_per_formation_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span></div></div></div>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Welcome to GemPy’s (v 0.9) documentation!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Kriging.html">Kriging structure of the <em>Potential field method</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code.html">Code</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Miguel de la Varga, CGR-Aachen Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>