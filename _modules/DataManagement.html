
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>DataManagement &#8212; GemPy 4 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for DataManagement</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">path</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># This is for sphenix to find the packages</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span> <span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span> <span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pn</span>
<span class="kn">from</span> <span class="nn">gempy</span> <span class="k">import</span> <span class="n">theanograf</span>
<span class="kn">import</span> <span class="nn">theano</span>


<div class="viewcode-block" id="InputData"><a class="viewcode-back" href="../code.html#DataManagement.InputData">[docs]</a><span class="k">class</span> <span class="nc">InputData</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    -DOCS NOT UPDATED- Class to import the raw data of the model and set data classifications into formations and series.</span>
<span class="sd">    This objects will contain the main information of the model/</span>

<span class="sd">    Args:</span>
<span class="sd">        extent (list):  [x_min, x_max, y_min, y_max, z_min, z_max]</span>
<span class="sd">        Resolution ((Optional[list])): [nx, ny, nz]. Defaults to 50</span>
<span class="sd">        path_i: Path to the data bases of interfaces. Default os.getcwd(),</span>
<span class="sd">        path_f: Path to the data bases of foliations. Default os.getcwd()</span>

<span class="sd">    Attributes:</span>
<span class="sd">        extent(list):  [x_min, x_max, y_min, y_max, z_min, z_max]</span>
<span class="sd">        resolution ((Optional[list])): [nx, ny, nz]</span>
<span class="sd">        Foliations(pandas.core.frame.DataFrame): Pandas data frame with the foliations data</span>
<span class="sd">        Interfaces(pandas.core.frame.DataFrame): Pandas data frame with the interfaces data</span>
<span class="sd">        series(pandas.core.frame.DataFrame): Pandas data frame which contains every formation within each series</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">extent</span><span class="p">,</span>
                 <span class="n">resolution</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
                 <span class="n">path_i</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path_f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># Set extent and resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>

        <span class="c1"># Init number of faults</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_faults</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># TODO choose the default source of data. So far only csv</span>
        <span class="c1"># Create the pandas dataframes</span>

        <span class="c1"># if we dont read a csv we create an empty dataframe with the columns that have to be filled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;formation&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">,</span> <span class="s1">&#39;X_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Z_std&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;dip_std&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth_std&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">,</span>
                                                <span class="s1">&#39;X_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Z_std&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">path_f</span> <span class="ow">or</span> <span class="n">path_i</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">import_data_csv</span><span class="p">(</span><span class="n">path_i</span><span class="o">=</span><span class="n">path_i</span><span class="p">,</span> <span class="n">path_f</span><span class="o">=</span><span class="n">path_f</span><span class="p">)</span>

        <span class="c1"># DEP-</span>
       <span class="c1"># self._set_formations()</span>

        <span class="c1"># If not provided set default series</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_series</span><span class="p">()</span>
        <span class="c1"># DEP- self.set_formation_number()</span>

        <span class="c1"># Compute gradients given azimuth and dips to plot data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_gradient</span><span class="p">()</span>

        <span class="c1"># Create default grid object. TODO: (Is this necessary now?)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid_type</span><span class="o">=</span><span class="s2">&quot;regular_3D&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># DEP</span>
        <span class="c1">#self.geo_data_type = &#39;InputData&#39;</span>

<div class="viewcode-block" id="InputData.import_data_csv"><a class="viewcode-back" href="../code.html#DataManagement.InputData.import_data_csv">[docs]</a>    <span class="k">def</span> <span class="nf">import_data_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_i</span><span class="p">,</span> <span class="n">path_f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to import interfaces and foliations from csv. The format is the same as the export 3D model data of</span>
<span class="sd">        GeoModeller (check in the input data folder for an example).</span>
<span class="sd">        Args:</span>
<span class="sd">            path_i (str): path to the csv table</span>
<span class="sd">            path_f (str): path to the csv table</span>
<span class="sd">            **kwargs: kwargs of Pandas load_csv</span>

<span class="sd">        Attributes:</span>
<span class="sd">            Foliations(pandas.core.frame.DataFrame): Pandas data frame with the foliations data</span>
<span class="sd">            Interfaces(pandas.core.frame.DataFrame): Pandas data frame with the interfaces data</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">path_f</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data_csv</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;foliations&quot;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path_f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> \
                <span class="s2">&quot;One or more columns do not match with the expected values &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">path_i</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_data_csv</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;interfaces&quot;</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path_i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> \
                <span class="s2">&quot;One or more columns do not match with the expected values &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span></div>

    <span class="c1"># def _set_formations(self):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     -DEPRECATED- Function to import the formations that will be used later on. By default all the formations in the tables are</span>
    <span class="c1">#     chosen.</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns:</span>
    <span class="c1">#          pandas.core.frame.DataFrame: Data frame with the raw data</span>
    <span class="c1">#</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         # foliations may or may not be in all formations so we need to use interfaces</span>
    <span class="c1">#         self.formations = self.interfaces[&quot;formation&quot;].unique()</span>
    <span class="c1">#</span>
    <span class="c1">#         # TODO: Trying to make this more elegant?</span>
    <span class="c1">#         # for el in self.formations:</span>
    <span class="c1">#         #     for check in self.formations:</span>
    <span class="c1">#         #         assert (el not in check or el == check), &quot;One of the formations name contains other&quot; \</span>
    <span class="c1">#         #                                                  &quot; string. Please rename.&quot; + str(el) + &quot; in &quot; + str(</span>
    <span class="c1">#         #             check)</span>
    <span class="c1">#</span>
    <span class="c1">#                 # TODO: Add the possibility to change the name in pandas directly</span>
    <span class="c1">#                 # (adding just a 1 in the contained string)</span>
    <span class="c1">#     except AttributeError:</span>
    <span class="c1">#         pass</span>

<div class="viewcode-block" id="InputData.calculate_gradient"><a class="viewcode-back" href="../code.html#DataManagement.InputData.calculate_gradient">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the gradient vector of module 1 given dip and azimuth to be able to plot the foliations</span>

<span class="sd">        Attributes:</span>
<span class="sd">            foliations: extra columns with components xyz of the unity vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;G_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;dip&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)))</span> <span class="o">*</span> \
                                 <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;azimuth&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)))</span> <span class="o">*</span> \
                                 <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;polarity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;G_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;dip&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)))</span> <span class="o">*</span> \
                                 <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;azimuth&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)))</span> <span class="o">*</span>\
                                 <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;polarity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;G_z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;dip&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)))</span> <span class="o">*</span>\
                                 <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;polarity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span></div>

    <span class="c1"># # DEP?</span>
    <span class="c1"># def create_grid(self, extent=None, resolution=None, grid_type=&quot;regular_3D&quot;, **kwargs):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Method to initialize the class grid. So far is really simple and only has the regular grid type</span>
    <span class="c1">#</span>
    <span class="c1">#     Args:</span>
    <span class="c1">#         grid_type (str): regular_3D or regular_2D (I am not even sure if regular 2D still working)</span>
    <span class="c1">#         **kwargs: Arbitrary keyword arguments.</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns:</span>
    <span class="c1">#         self.grid(GeMpy_core.grid): Object that contain different grids</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#     if not extent:</span>
    <span class="c1">#         extent = self.extent</span>
    <span class="c1">#     if not resolution:</span>
    <span class="c1">#         resolution = self.resolution</span>
    <span class="c1">#</span>
    <span class="c1">#   return self.GridClass(extent, resolution, grid_type=grid_type, **kwargs)</span>

<div class="viewcode-block" id="InputData.set_grid"><a class="viewcode-back" href="../code.html#DataManagement.InputData.set_grid">[docs]</a>    <span class="k">def</span> <span class="nf">set_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid_type</span><span class="o">=</span><span class="s2">&quot;regular_3D&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to initialize the class new_grid. So far is really simple and only has the regular new_grid type</span>

<span class="sd">        Args:</span>
<span class="sd">            grid_type (str): regular_3D or regular_2D (I am not even sure if regular 2D still working)</span>
<span class="sd">            **kwargs: Arbitrary keyword arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            self.new_grid(GeMpy_core.new_grid): Object that contain different grids</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">new_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;The shape of new grid must be (n,3) where n is&#39;</span> \
                                                                        <span class="s1">&#39;the number of points of the grid&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">new_grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">extent</span><span class="p">:</span>
                <span class="n">extent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">resolution</span><span class="p">:</span>
                <span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span>

            <span class="k">return</span> <span class="n">GridClass</span><span class="p">(</span><span class="n">extent</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">grid_type</span><span class="o">=</span><span class="n">grid_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.data_to_pickle"><a class="viewcode-back" href="../code.html#DataManagement.InputData.data_to_pickle">[docs]</a>    <span class="k">def</span> <span class="nf">data_to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save InputData object to a python pickle (serialization of python). Be aware that if the dependencies</span>
<span class="sd">        versions used to export and import the pickle differ it may give problems</span>
<span class="sd">        :param path (str): path where save the pickle</span>
<span class="sd">        :return:</span>
<span class="sd">          None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;./geo_data&#39;</span>
        <span class="kn">import</span> <span class="nn">pickle</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="o">+</span><span class="s1">&#39;.pickle&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1"># Pickle the &#39;data&#39; dictionary using the highest protocol available.</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.get_raw_data"><a class="viewcode-back" href="../code.html#DataManagement.InputData.get_raw_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_raw_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itype</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that returns the interfaces and foliations pandas Dataframes. Can return both at the same time or only</span>
<span class="sd">        one of the two</span>
<span class="sd">        Args:</span>
<span class="sd">            itype: input data type, either &#39;foliations&#39;, &#39;interfaces&#39; or &#39;all&#39; for both.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.core.frame.DataFrame: Data frame with the raw data</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pn</span>
        <span class="k">if</span> <span class="n">itype</span> <span class="o">==</span> <span class="s1">&#39;foliations&#39;</span><span class="p">:</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span>
        <span class="k">elif</span> <span class="n">itype</span> <span class="o">==</span> <span class="s1">&#39;interfaces&#39;</span><span class="p">:</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span>
        <span class="k">elif</span> <span class="n">itype</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">],</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;interfaces&#39;</span><span class="p">,</span> <span class="s1">&#39;foliations&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">raw_data</span></div>

<div class="viewcode-block" id="InputData.i_open_set_data"><a class="viewcode-back" href="../code.html#DataManagement.InputData.i_open_set_data">[docs]</a>    <span class="k">def</span> <span class="nf">i_open_set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itype</span><span class="o">=</span><span class="s2">&quot;foliations&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to have interactive pandas tables in jupyter notebooks. The idea is to use this method to interact with</span>
<span class="sd">         the table and i_close_set_data to recompute the parameters that depend on the changes made. I did not find a</span>
<span class="sd">         easier solution than calling two different methods.</span>
<span class="sd">        Args:</span>
<span class="sd">            itype: input data type, either &#39;foliations&#39; or &#39;interfaces&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.core.frame.DataFrame: Data frame with the changed data on real time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">qgrid</span>
        <span class="k">except</span> <span class="n">ModuleNotFoundError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModuleNotFoundError</span><span class="p">(</span><span class="s1">&#39;It is necessary to instal qgrid to have interactive tables&#39;</span><span class="p">)</span>

        <span class="c1"># if the data frame is empty the interactive table is bugged. Therefore I create a default raw when the method</span>
        <span class="c1"># is called</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="s1">&#39;Default Formation&#39;</span><span class="p">,</span> <span class="s1">&#39;Default series&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">])</span><span class="o">.</span>\
                <span class="n">convert_objects</span><span class="p">(</span><span class="n">convert_numeric</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Default Formation&#39;</span><span class="p">,</span> <span class="s1">&#39;Default series&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">convert_objects</span><span class="p">(</span><span class="n">convert_numeric</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Setting some options</span>
        <span class="n">qgrid</span><span class="o">.</span><span class="n">nbinstall</span><span class="p">(</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">qgrid</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="n">show_toolbar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">itype</span> <span class="ow">is</span> <span class="s1">&#39;foliations&#39;</span> <span class="ow">or</span> <span class="n">itype</span> <span class="ow">is</span> <span class="s1">&#39;interfaces&#39;</span><span class="p">,</span> <span class="s1">&#39;itype must be either foliations or interfaces&#39;</span>

        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Remember to call i_close_set_data after the editing.&#39;</span><span class="p">)</span>

        <span class="c1"># We kind of set the show grid to a variable so we can close it afterwards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pandas_frame</span> <span class="o">=</span> <span class="n">qgrid</span><span class="o">.</span><span class="n">show_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_raw_data</span><span class="p">(</span><span class="n">itype</span><span class="o">=</span><span class="n">itype</span><span class="p">))</span></div>

<div class="viewcode-block" id="InputData.i_close_set_data"><a class="viewcode-back" href="../code.html#DataManagement.InputData.i_close_set_data">[docs]</a>    <span class="k">def</span> <span class="nf">i_close_set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to have interactive pandas tables in jupyter notebooks. The idea is to use this method to interact with</span>
<span class="sd">         the table and i_close_set_data to recompute the parameters that depend on the changes made. I did not find a</span>
<span class="sd">         easier solution than calling two different methods.</span>
<span class="sd">        Args:</span>
<span class="sd">            itype: input data type, either &#39;foliations&#39; or &#39;interfaces&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.core.frame.DataFrame: Data frame with the changed data on real time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We close it to guarantee that after this method it is not possible further modifications</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pandas_frame</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Set parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_series</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_gradient</span><span class="p">()</span></div>

<div class="viewcode-block" id="InputData.load_data_csv"><a class="viewcode-back" href="../code.html#DataManagement.InputData.load_data_csv">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">load_data_csv</span><span class="p">(</span><span class="n">data_type</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to load either interface or foliations data csv files. Normally this is in which GeoModeller exports it</span>

<span class="sd">        Args:</span>
<span class="sd">            data_type (str): &#39;interfaces&#39; or &#39;foliations&#39;</span>
<span class="sd">            path (str): path to the files. Default os.getcwd()</span>
<span class="sd">            **kwargs: Arbitrary keyword arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.core.frame.DataFrame: Data frame with the raw data</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: in case that the columns have a different name specify in pandas which columns are interfaces /</span>
        <span class="c1">#  coordinates, dips and so on.</span>
        <span class="c1"># TODO: use pandas to read any format file not only csv</span>

        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;foliations&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pn</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s1">&#39;interfaces&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pn</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Data type not understood. Try interfaces or foliations&#39;</span><span class="p">)</span></div>

        <span class="c1"># TODO if we load different data the Interpolator parameters must be also updated. Prob call gradients and</span>
        <span class="c1"># series</span>

<div class="viewcode-block" id="InputData.set_interfaces"><a class="viewcode-back" href="../code.html#DataManagement.InputData.set_interfaces">[docs]</a>    <span class="k">def</span> <span class="nf">set_interfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interf_Dataframe</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to change or append a Dataframe to interfaces in place. A equivalent Pandas Dataframe with</span>
<span class="sd">        [&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;formation&#39;] has to be passed.</span>
<span class="sd">        Args:</span>
<span class="sd">            interf_Dataframe: pandas.core.frame.DataFrame with the data</span>
<span class="sd">            append: Bool: if you want to append the new data frame or substitute it</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">interf_Dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> \
            <span class="s2">&quot;One or more columns do not match with the expected values &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">interf_Dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interf_Dataframe</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span> <span class="o">=</span> <span class="n">interf_Dataframe</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_series</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span></div>
       <span class="c1"># self.interfaces.reset_index(drop=True, inplace=True)</span>

<div class="viewcode-block" id="InputData.set_foliations"><a class="viewcode-back" href="../code.html#DataManagement.InputData.set_foliations">[docs]</a>    <span class="k">def</span> <span class="nf">set_foliations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">foliat_Dataframe</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Method to change or append a Dataframe to foliations in place.  A equivalent Pandas Dataframe with</span>
<span class="sd">        [&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;dip&#39;, &#39;azimuth&#39;, &#39;polarity&#39;, &#39;formation&#39;] has to be passed.</span>
<span class="sd">          Args:</span>
<span class="sd">              interf_Dataframe: pandas.core.frame.DataFrame with the data</span>
<span class="sd">              append: Bool: if you want to append the new data frame or substitute it</span>
<span class="sd">          &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;dip&#39;</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;polarity&#39;</span><span class="p">,</span> <span class="s1">&#39;formation&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span>
            <span class="n">foliat_Dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="s2">&quot;One or more columns do not match with the expected values &quot;</span> <span class="o">+</span>\
                                       <span class="nb">str</span><span class="p">(</span><span class="n">foliat_Dataframe</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">foliat_Dataframe</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span> <span class="o">=</span> <span class="n">foliat_Dataframe</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_series</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_gradient</span><span class="p">()</span></div>
      <span class="c1">#  self.foliations.reset_index(drop=True, inplace=True)</span>

<div class="viewcode-block" id="InputData.set_series"><a class="viewcode-back" href="../code.html#DataManagement.InputData.set_series">[docs]</a>    <span class="k">def</span> <span class="nf">set_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series_distribution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to define the different series of the project.</span>

<span class="sd">        Args:</span>
<span class="sd">            series_distribution (dict): with the name of the serie as key and the name of the formations as values.</span>
<span class="sd">            order(Optional[list]): order of the series by default takes the dictionary keys which until python 3.6 are</span>
<span class="sd">                random. This is important to set the erosion relations between the different series</span>

<span class="sd">        Returns:</span>
<span class="sd">            self.series: A pandas DataFrame with the series and formations relations</span>
<span class="sd">            self.interfaces: one extra column with the given series</span>
<span class="sd">            self.foliations: one extra column with the given series</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">series_distribution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set to default series</span>
            <span class="c1"># TODO see if some of the formations have already a series and not overwrite</span>
            <span class="n">_series</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Default serie&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()}</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">series_distribution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">,</span> <span class="s2">&quot;series_distribution must be a dictionary, &quot;</span> \
                                                      <span class="s2">&quot;see Docstring for more information&quot;</span>

            <span class="c1"># TODO if self.series exist already maybe we should append instead of overwrite</span>
            <span class="n">_series</span> <span class="o">=</span> <span class="n">series_distribution</span>

        <span class="c1"># The order of the series is very important since it dictates which one is on top of the stratigraphic pile</span>
        <span class="c1"># If it is not given we take the dictionaries keys. NOTICE that until python 3.6 these keys are pretty much</span>
        <span class="c1"># random</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">_series</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># TODO assert len order is equal to len of the dictionary</span>

        <span class="c1"># We create a dataframe with the links</span>
        <span class="n">_series</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">_series</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

        <span class="c1"># Now we fill the column series in the interfaces and foliations tables with the correspondant series and</span>
        <span class="c1"># assigned number to the series</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;series&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_series</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;order_series&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_series</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;series&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_series</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;order_series&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">==</span> <span class="n">_series</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
                                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]]</span>

        <span class="c1"># We sort the series altough is only important for the computation (we will do it again just before computing)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;order_series&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;order_series&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Save the dataframe in a property</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="o">=</span> <span class="n">_series</span>

        <span class="c1"># Set default faults</span>
        <span class="n">faults_series</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;fault&#39;</span> <span class="ow">in</span> <span class="n">i</span> <span class="ow">or</span> <span class="s1">&#39;Fault&#39;</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;Default&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">faults_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_faults</span><span class="p">(</span><span class="n">faults_series</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_indices</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">_series</span></div>

<div class="viewcode-block" id="InputData.set_faults"><a class="viewcode-back" href="../code.html#DataManagement.InputData.set_faults">[docs]</a>    <span class="k">def</span> <span class="nf">set_faults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a flag to the series that are faults.</span>
<span class="sd">        Args:</span>
<span class="sd">            series_name(list or array_like): Name of the series which are faults</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">series_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;isFault&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;series&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">series_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;isFault&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;series&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">series_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_faults</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">series_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.order_table"><a class="viewcode-back" href="../code.html#DataManagement.InputData.order_table">[docs]</a>    <span class="k">def</span> <span class="nf">order_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First we sort the dataframes by the series age. Then we set a unique number for every formation and resort</span>
<span class="sd">        the formations. All inplace</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We order the pandas table by series</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">],</span>  <span class="c1"># , &#39;formation number&#39;],</span>
                                                 <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                 <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">],</span>  <span class="c1"># , &#39;formation number&#39;],</span>
                                                 <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                 <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Give formation number</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;formation number&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># print(&#39;I am here&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_formation_number</span><span class="p">()</span>

        <span class="c1"># We order the pandas table by formation (also by series in case something weird happened)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">,</span> <span class="s1">&#39;formation number&#39;</span><span class="p">],</span>
                                                 <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                 <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">,</span> <span class="s1">&#39;formation number&#39;</span><span class="p">],</span>
                                                 <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                 <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Pandas dataframe set an index to every row when the dataframe is created. Sorting the table does not reset</span>
        <span class="c1"># the index. For some of the methods (pn.drop) we have to apply afterwards we need to reset these indeces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.set_formation_number"><a class="viewcode-back" href="../code.html#DataManagement.InputData.set_formation_number">[docs]</a>    <span class="k">def</span> <span class="nf">set_formation_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formation_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a unique number to each formation. NOTE: this method is getting deprecated since the user does not need</span>
<span class="sd">        to know it and also now the numbers must be set in the order of the series as well. Therefore this method</span>
<span class="sd">        has been moved to the interpolator class as preprocessing</span>

<span class="sd">        Returns: Column in the interfaces and foliations dataframes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">formation_order</span><span class="p">:</span>
            <span class="n">formation_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ip_addresses</span> <span class="o">=</span> <span class="n">formation_order</span>
            <span class="n">ip_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ip_addresses</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ip_addresses</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ip_dict</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;formation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ip_dict</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="InputData.reset_indices"><a class="viewcode-back" href="../code.html#DataManagement.InputData.reset_indices">[docs]</a>    <span class="k">def</span> <span class="nf">reset_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets dataframe indices for foliations and interfaces.</span>
<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.interface_modify"><a class="viewcode-back" href="../code.html#DataManagement.InputData.interface_modify">[docs]</a>    <span class="k">def</span> <span class="nf">interface_modify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allows modification of the x,y and/or z-coordinates of an interface at specified dataframe index.</span>
<span class="sd">        Args:</span>
<span class="sd">            index: dataframe index of the foliation point</span>
<span class="sd">            **kwargs: X, Y, Z (int or float)</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

<div class="viewcode-block" id="InputData.interface_add"><a class="viewcode-back" href="../code.html#DataManagement.InputData.interface_add">[docs]</a>    <span class="k">def</span> <span class="nf">interface_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds interface to dataframe.</span>
<span class="sd">        Args:</span>
<span class="sd">            **kwargs: X, Y, Z, formation, labels, order_series, series</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_series</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span></div>

<div class="viewcode-block" id="InputData.interface_drop"><a class="viewcode-back" href="../code.html#DataManagement.InputData.interface_drop">[docs]</a>    <span class="k">def</span> <span class="nf">interface_drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drops interface from dataframe identified by index</span>
<span class="sd">        Args:</span>
<span class="sd">            index: dataframe index</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.foliation_modify"><a class="viewcode-back" href="../code.html#DataManagement.InputData.foliation_modify">[docs]</a>    <span class="k">def</span> <span class="nf">foliation_modify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allows modification of foliation data at specified dataframe index.</span>
<span class="sd">        Args:</span>
<span class="sd">            index: dataframe index of the foliation point</span>
<span class="sd">            **kwargs: G_x, G_y, G_z, X, Y, Z, azimuth, dip, formation, labels, order_series, polarity</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_gradient</span><span class="p">()</span></div>

<div class="viewcode-block" id="InputData.foliation_add"><a class="viewcode-back" href="../code.html#DataManagement.InputData.foliation_add">[docs]</a>    <span class="k">def</span> <span class="nf">foliation_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds foliation to dataframe.</span>
<span class="sd">        Args:</span>
<span class="sd">            **kwargs: G_x, G_y, G_z, X, Y, Z, azimuth, dip, formation, labels, order_series, polarity, series</span>

<span class="sd">        Returns: Nothing</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_gradient</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_series</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span></div>

<div class="viewcode-block" id="InputData.foliations_drop"><a class="viewcode-back" href="../code.html#DataManagement.InputData.foliations_drop">[docs]</a>    <span class="k">def</span> <span class="nf">foliations_drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drops foliation from dataframe identified by index</span>
<span class="sd">        Args:</span>
<span class="sd">            index: dataframe index</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="InputData.get_formation_number"><a class="viewcode-back" href="../code.html#DataManagement.InputData.get_formation_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_formation_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a dictionary with the key the name of the formation and the value their number</span>
<span class="sd">        :return:</span>
<span class="sd">            dict: key the name of the formation and the value their number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pn_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;formation number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">formation</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">ip_addresses</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pn_series</span><span class="p">):</span>
            <span class="n">ip_addresses</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ip_addresses</span><span class="p">[</span><span class="s1">&#39;DefaultBasement&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">ip_addresses</span></div></div>

    <span class="c1"># # TODO think where this function should go</span>
    <span class="c1"># def read_vox(self, path):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     read vox from geomodeller and transform it to gempy format</span>
    <span class="c1">#     Returns:</span>
    <span class="c1">#         numpy.array: block model</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#     geo_res = pn.read_csv(path)</span>
    <span class="c1">#</span>
    <span class="c1">#     geo_res = geo_res.iloc[9:]</span>
    <span class="c1">#</span>
    <span class="c1">#     #ip_addresses = geo_res[&#39;nx 50&#39;].unique()  # geo_data.interfaces[&quot;formation&quot;].unique()</span>
    <span class="c1">#     ip_dict = self.get_formation_number()</span>
    <span class="c1">#</span>
    <span class="c1">#     geo_res_num = geo_res.iloc[:, 0].replace(ip_dict)</span>
    <span class="c1">#     block_geomodeller = np.ravel(geo_res_num.as_matrix().reshape(</span>
    <span class="c1">#                                     self.resolution[0], self.resolution[1], self.resolution[2], order=&#39;C&#39;).T)</span>
    <span class="c1">#     return block_geomodeller</span>


<div class="viewcode-block" id="GridClass"><a class="viewcode-back" href="../code.html#DataManagement.GridClass">[docs]</a><span class="k">class</span> <span class="nc">GridClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    -DOCS NOT UPDATED- Class with set of functions to generate grids</span>

<span class="sd">    Args:</span>
<span class="sd">        extent (list):  [x_min, x_max, y_min, y_max, z_min, z_max]</span>
<span class="sd">        resolution (list): [nx, ny, nz].</span>
<span class="sd">        grid_type(str): Type of grid. So far only regular 3D is implemented</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">grid_type</span><span class="o">=</span><span class="s2">&quot;regular_3D&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span> <span class="o">=</span> <span class="n">extent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid_res</span> <span class="o">=</span> <span class="n">resolution</span>

        <span class="k">if</span> <span class="n">grid_type</span> <span class="o">==</span> <span class="s2">&quot;regular_3D&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_regular_grid_3d</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Wrong type&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="GridClass.create_regular_grid_3d"><a class="viewcode-back" href="../code.html#DataManagement.GridClass.create_regular_grid_3d">[docs]</a>    <span class="k">def</span> <span class="nf">create_regular_grid_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to create a 3D regular grid where is interpolated</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Unraveled 3D numpy array where every row correspond to the xyz coordinates of a regular grid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_ext</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_res</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">,</span> <span class="n">g</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">InterpolatorInput</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geo_data</span><span class="p">,</span> <span class="n">compile_theano</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compute_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">u_grade</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rescaling_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO add all options before compilation in here. Basically this is n_faults, n_layers, verbose, dtype, and \</span>
        <span class="c1"># only block or all</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="n">InputData</span><span class="p">),</span> <span class="s1">&#39;You need to pass a InputData object&#39;</span>
        <span class="c1"># Here we can change the dtype for stability and GPU vs CPU</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geo_data_type</span> <span class="o">=</span> <span class="s1">&#39;InterpolatorInput&#39;</span>

        <span class="c1">#self.in_data = self.rescale_data(geo_data, rescaling_factor=rescaling_factor)</span>
        <span class="c1"># Set some parameters. TODO posibly this should go in kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_grade</span> <span class="o">=</span> <span class="n">u_grade</span>

        <span class="c1"># This two properties get set calling rescale data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rescaling_factor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extent_rescaled</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Rescaling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_data</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="n">rescaling_factor</span><span class="o">=</span><span class="n">rescaling_factor</span><span class="p">)</span>

        <span class="c1"># # This are necessary parameters for the visualization package</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent_rescaled</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

        <span class="c1"># Creating interpolator class with all the precompilation options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_interpolator</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">compile_theano</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">th_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compile_th_fn</span><span class="p">(</span><span class="n">compute_all</span><span class="o">=</span><span class="n">compute_all</span><span class="p">)</span>

    <span class="c1"># DEP all options since it goes in set_interpolator</span>
    <span class="k">def</span> <span class="nf">compile_th_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compute_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">u_grade</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            geo_data:</span>
<span class="sd">            **kwargs:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Choosing float precision for the computation</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dtype</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">device</span> <span class="o">==</span> <span class="s1">&#39;gpu&#39;</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float32&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;float64&#39;</span>

        <span class="c1"># We make a rescaled version of geo_data for stability reasons</span>
        <span class="c1">#data_interp = self.set_interpolator(geo_data, dtype=dtype)</span>

        <span class="c1"># This are the shared parameters and the compilation of the function. This will be hidden as well at some point</span>
        <span class="n">input_data_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">input_parameters_list</span><span class="p">()</span>

        <span class="c1"># This prepares the user data to the theano function</span>
        <span class="c1"># input_data_P = data_interp.interpolator.data_prep(u_grade=u_grade)</span>

        <span class="c1"># then we compile we have to pass the number of formations that are faults!!</span>
        <span class="n">th_fn</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">input_data_T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">whole_block_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">n_faults</span><span class="p">,</span>
                                                                                     <span class="n">compute_all</span><span class="o">=</span><span class="n">compute_all</span><span class="p">),</span>
                                <span class="n">on_unused_input</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                                <span class="n">allow_input_downcast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">profile</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">th_fn</span>

    <span class="k">def</span> <span class="nf">rescale_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geo_data</span><span class="p">,</span> <span class="n">rescaling_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rescale the data of a DataManagement object between 0 and 1 due to stability problem of the float32.</span>
<span class="sd">        Args:</span>
<span class="sd">            geo_data: DataManagement object with the real scale data</span>
<span class="sd">            rescaling_factor(float): factor of the rescaling. Default to maximum distance in one the axis</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO split this function in compute rescaling factor and rescale z</span>
        <span class="n">max_coord</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">,</span> <span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span>
        <span class="n">min_coord</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">,</span> <span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">rescaling_factor</span><span class="p">:</span>
            <span class="n">rescaling_factor</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">max_coord</span> <span class="o">-</span> <span class="n">min_coord</span><span class="p">)</span>

        <span class="n">centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_coord</span> <span class="o">+</span> <span class="n">min_coord</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">new_coord_interfaces</span> <span class="o">=</span> <span class="p">(</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span> <span class="o">-</span>
                                <span class="n">centers</span><span class="p">)</span> <span class="o">/</span> <span class="n">rescaling_factor</span> <span class="o">+</span> <span class="mf">0.5001</span>

        <span class="n">new_coord_foliations</span> <span class="o">=</span> <span class="p">(</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span> <span class="o">-</span>
                                <span class="n">centers</span><span class="p">)</span> <span class="o">/</span> <span class="n">rescaling_factor</span> <span class="o">+</span> <span class="mf">0.5001</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># print(&#39;I am here&#39;)</span>
            <span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[[</span><span class="s1">&#39;X_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Z_std&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">geo_data</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span>
                                                                    <span class="p">[</span><span class="s1">&#39;X_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Z_std&#39;</span><span class="p">]])</span> <span class="o">/</span> <span class="n">rescaling_factor</span>
            <span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[[</span><span class="s1">&#39;X_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Z_std&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">geo_data</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span>
                                                                    <span class="p">[</span><span class="s1">&#39;X_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_std&#39;</span><span class="p">,</span> <span class="s1">&#39;Z_std&#39;</span><span class="p">]])</span> <span class="o">/</span> <span class="n">rescaling_factor</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">new_coord_extent</span> <span class="o">=</span> <span class="p">(</span><span class="n">geo_data</span><span class="o">.</span><span class="n">extent</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">rescaling_factor</span> <span class="o">+</span> <span class="mf">0.5001</span>

        <span class="n">geo_data_rescaled</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">geo_data</span><span class="p">)</span>
        <span class="n">geo_data_rescaled</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_coord_interfaces</span>
        <span class="n">geo_data_rescaled</span><span class="o">.</span><span class="n">foliations</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_coord_foliations</span>
        <span class="n">geo_data_rescaled</span><span class="o">.</span><span class="n">extent</span> <span class="o">=</span> <span class="n">new_coord_extent</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

        <span class="n">geo_data_rescaled</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">geo_data</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span> <span class="o">-</span> <span class="n">centers</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">())</span> <span class="o">/</span> <span class="n">rescaling_factor</span> <span class="o">+</span> <span class="mf">0.5001</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rescaling_factor</span> <span class="o">=</span> <span class="n">rescaling_factor</span>
        <span class="n">geo_data_rescaled</span><span class="o">.</span><span class="n">rescaling_factor</span> <span class="o">=</span> <span class="n">rescaling_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centers</span> <span class="o">=</span> <span class="n">centers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extent_rescaled</span> <span class="o">=</span> <span class="n">new_coord_extent</span>

        <span class="k">return</span> <span class="n">geo_data_rescaled</span>

    <span class="k">def</span> <span class="nf">get_formation_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pn_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;formation number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">formation</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">ip_addresses</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pn_series</span><span class="p">):</span>
            <span class="n">ip_addresses</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ip_addresses</span><span class="p">[</span><span class="s1">&#39;DefaultBasement&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">ip_addresses</span>

    <span class="c1"># DEP?</span>
    <span class="k">def</span> <span class="nf">set_airbore_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">res_grav</span><span class="p">):</span>

        <span class="c1"># Rescale z</span>
        <span class="n">z_res</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">centers</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">rescaling_factor</span> <span class="o">+</span> <span class="mf">0.5001</span>

        <span class="c1"># Create xy meshgrid</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent_rescaled</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">extent_rescaled</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">res_grav</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent_rescaled</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">extent_rescaled</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">res_grav</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">res_grav</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">res_grav</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">z_res</span>

        <span class="c1"># Transformation</span>
        <span class="n">xy_ravel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">,</span> <span class="n">xy</span><span class="p">))</span>
        <span class="n">airborne_plane</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">xy_ravel</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">airborne_plane</span>

    <span class="k">def</span> <span class="nf">set_interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geo_data</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to initialize the class interpolator. All the constant parameters for the interpolation can be passed</span>
<span class="sd">        as args, otherwise they will take the default value (TODO: documentation of the dafault values)</span>

<span class="sd">        Args:</span>
<span class="sd">            *args: Variable length argument list</span>
<span class="sd">            **kwargs: Arbitrary keyword arguments.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            range_var: Range of the variogram. Default None</span>
<span class="sd">            c_o: Covariance at 0. Default None</span>
<span class="sd">            nugget_effect: Nugget effect of the gradients. Default 0.01</span>
<span class="sd">            u_grade: Grade of the polynomial used in the universal part of the Kriging. Default 2</span>
<span class="sd">            rescaling_factor: Magic factor that multiplies the covariances). Default 2</span>

<span class="sd">        Returns:</span>
<span class="sd">            self.Interpolator (GeMpy_core.Interpolator): Object to perform the potential field method</span>
<span class="sd">            self.Plot(GeMpy_core.PlotData): Object to visualize data and results. It gets updated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;u_grade&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">compile_theano</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">range_var</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;range_var&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">rescaling_factor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rescaling_factor&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


        <span class="c1">#DEP?</span>
        <span class="c1">#if not getattr(geo_data, &#39;grid&#39;, None):</span>
        <span class="c1">#    set_grid(geo_data)</span>

        <span class="k">if</span> <span class="n">geo_data</span><span class="p">:</span>
            <span class="n">geo_data_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_data</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="n">rescaling_factor</span><span class="o">=</span><span class="n">rescaling_factor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">geo_data_in</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">geo_data_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># First creation</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;interpolator&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># print(&#39;I am in the setting&#39;)</span>
            <span class="n">interpolator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">InterpolatorClass</span><span class="p">(</span><span class="n">geo_data_in</span><span class="p">,</span> <span class="n">geo_data_in</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Update</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;I am in update&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">_data_scaled</span> <span class="o">=</span> <span class="n">geo_data_in</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">_grid_scaled</span> <span class="o">=</span> <span class="n">geo_data_in</span><span class="o">.</span><span class="n">grid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">set_theano_shared_parameteres</span><span class="p">(</span><span class="n">range_var</span><span class="o">=</span><span class="n">range_var</span><span class="p">)</span>
            <span class="n">interpolator</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">interpolator</span>

    <span class="k">def</span> <span class="nf">update_interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geo_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update variables without compiling the theano function</span>
<span class="sd">        Args:</span>
<span class="sd">            geo_data:</span>
<span class="sd">            *args:</span>
<span class="sd">            **kwargs:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;u_grade&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">compile_theano</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">range_var</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;range_var&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">rescaling_factor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rescaling_factor&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">geo_data</span><span class="p">:</span>
            <span class="n">geo_data_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rescale_data</span><span class="p">(</span><span class="n">geo_data</span><span class="p">,</span> <span class="n">rescaling_factor</span><span class="o">=</span><span class="n">rescaling_factor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">geo_data_in</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">geo_data_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;I am in update&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">_data_scaled</span> <span class="o">=</span> <span class="n">geo_data_in</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">_grid_scaled</span> <span class="o">=</span> <span class="n">geo_data_in</span><span class="o">.</span><span class="n">grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">set_theano_shared_parameteres</span><span class="p">(</span><span class="n">range_var</span><span class="o">=</span><span class="n">range_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_input_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u_grade</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">u_grade</span><span class="p">:</span>
            <span class="n">u_grade</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_grade</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">data_prep</span><span class="p">(</span><span class="n">u_grade</span><span class="o">=</span><span class="n">u_grade</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">InterpolatorClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        -DOCS NOT UPDATED- Class which contain all needed methods to perform potential field implicit modelling in theano</span>

<span class="sd">        Args:</span>
<span class="sd">            _data(GeMpy_core.DataManagement): All values of a DataManagement object</span>
<span class="sd">            _grid(GeMpy_core.grid): A grid object</span>
<span class="sd">            **kwargs: Arbitrary keyword arguments.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            verbose(int): Level of verbosity during the execution of the functions (up to 5). Default 0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_data_scaled</span><span class="p">,</span> <span class="n">_grid_scaled</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

            <span class="c1"># verbose is a list of strings. See theanograph</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># -DEP-rescaling_factor = kwargs.get(&#39;rescaling_factor&#39;, None)</span>

            <span class="c1"># Here we can change the dtype for stability and GPU vs CPU</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">range_var</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;range_var&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Drift grade</span>
            <span class="n">u_grade</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;u_grade&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>



            <span class="c1"># We hide the scaled copy of DataManagement object from the user. The scaling happens in gempy what is a</span>
            <span class="c1"># bit weird. Maybe at some point I should bring the function to this module</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span> <span class="o">=</span> <span class="n">_data_scaled</span>

            <span class="c1"># In case someone wants to provide a grid otherwise we extract it from the DataManagement object.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_grid_scaled</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid_scaled</span> <span class="o">=</span> <span class="n">_data_scaled</span><span class="o">.</span><span class="n">grid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid_scaled</span> <span class="o">=</span> <span class="n">_grid_scaled</span>

            <span class="c1"># Importing the theano graph. The methods of this object generate different parts of graph.</span>
            <span class="c1"># See theanograf doc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span> <span class="o">=</span> <span class="n">theanograf</span><span class="o">.</span><span class="n">TheanoGraph_pro</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,)</span>

            <span class="c1"># Sorting data in case the user provides it unordered</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_table</span><span class="p">()</span>

            <span class="c1"># Setting theano parameters</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_theano_shared_parameteres</span><span class="p">(</span><span class="n">range_var</span><span class="o">=</span><span class="n">range_var</span><span class="p">)</span>

            <span class="c1"># Extracting data from the pandas dataframe to numpy array in the required form for the theano function</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_prep</span><span class="p">(</span><span class="n">u_grade</span><span class="o">=</span><span class="n">u_grade</span><span class="p">)</span>

            <span class="c1"># Avoid crashing my pc</span>
            <span class="kn">import</span> <span class="nn">theano</span>
            <span class="k">if</span> <span class="n">theano</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">optimizer</span> <span class="o">!=</span> <span class="s1">&#39;fast_run&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">grid_val_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> \
                       <span class="n">np</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">len_series_i</span><span class="o">.</span><span class="n">get_value</span><span class="p">()))</span> <span class="o">&lt;</span> <span class="mf">2e7</span><span class="p">,</span> \
                       <span class="s1">&#39;The grid is too big for the number of potential fields. Reduce the grid or change the&#39;</span> \
                       <span class="s1">&#39;optimization flag to fast run&#39;</span>

        <span class="k">def</span> <span class="nf">set_formation_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    Set a unique number to each formation. NOTE: this method is getting deprecated since the user does not need</span>
<span class="sd">                    to know it and also now the numbers must be set in the order of the series as well. Therefore this method</span>
<span class="sd">                    has been moved to the interpolator class as preprocessing</span>

<span class="sd">            Returns: Column in the interfaces and foliations dataframes</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ip_addresses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s2">&quot;formation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
                <span class="n">ip_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ip_addresses</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ip_addresses</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ip_dict</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;formation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ip_dict</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">def</span> <span class="nf">order_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            First we sort the dataframes by the series age. Then we set a unique number for every formation and resort</span>
<span class="sd">            the formations. All inplace</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># We order the pandas table by series</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">],</span>  <span class="c1"># , &#39;formation number&#39;],</span>
                                                     <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                     <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">],</span>  <span class="c1"># , &#39;formation number&#39;],</span>
                                                     <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                     <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Give formation number</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;formation number&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c1"># print(&#39;I am here&#39;)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_formation_number</span><span class="p">()</span>

            <span class="c1"># We order the pandas table by formation (also by series in case something weird happened)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">,</span> <span class="s1">&#39;formation number&#39;</span><span class="p">],</span>
                                                     <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                     <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">foliations</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">,</span> <span class="s1">&#39;formation number&#39;</span><span class="p">],</span>
                                                     <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">,</span>
                                                     <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Pandas dataframe set an index to every row when the dataframe is created. Sorting the table does not reset</span>
            <span class="c1"># the index. For some of the methods (pn.drop) we have to apply afterwards we need to reset these indeces</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">data_prep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Ideally this method will extract the data from the pandas dataframes to individual numpy arrays to be input</span>
<span class="sd">            of the theano function. However since some of the shared parameters are function of these arrays shape I also</span>
<span class="sd">            set them here</span>
<span class="sd">            Returns:</span>
<span class="sd">                idl (list): List of arrays which are the input for the theano function:</span>
<span class="sd">                    - numpy.array: dips_position</span>
<span class="sd">                    - numpy.array: dip_angles</span>
<span class="sd">                    - numpy.array: azimuth</span>
<span class="sd">                    - numpy.array: polarity</span>
<span class="sd">                    - numpy.array: ref_layer_points</span>
<span class="sd">                    - numpy.array: rest_layer_points</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">u_grade</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;u_grade&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># ==================</span>
            <span class="c1"># Extracting lengths</span>
            <span class="c1"># ==================</span>
            <span class="c1"># Array containing the size of every formation. Interfaces</span>
            <span class="n">len_interfaces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()])</span>

            <span class="c1"># Size of every layer in rests. SHARED (for theano)</span>
            <span class="n">len_rest_form</span> <span class="o">=</span> <span class="p">(</span><span class="n">len_interfaces</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">number_of_points_per_formation_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">len_rest_form</span><span class="p">)</span>

            <span class="c1"># Position of the first point of every layer</span>
            <span class="n">ref_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">len_interfaces</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

            <span class="c1"># Drop the reference points using pandas indeces to get just the rest_layers array</span>
            <span class="n">pandas_rest_layer_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">ref_position</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pandas_rest_layer_points</span> <span class="o">=</span> <span class="n">pandas_rest_layer_points</span>
            <span class="c1"># TODO: do I need this? PYTHON</span>
            <span class="c1"># DEP- because per series the foliations do not belong to a formation but to the whole series</span>
            <span class="c1"># len_foliations = np.asarray(</span>
            <span class="c1">#     [np.sum(self._data_scaled.foliations[&#39;formation number&#39;] == i)</span>
            <span class="c1">#      for i in self._data_scaled.foliations[&#39;formation number&#39;].unique()])</span>

            <span class="c1"># -DEP- I think this was just a kind of print to know what was going on</span>
            <span class="c1">#self.pandas_rest = pandas_rest_layer_points</span>

            <span class="c1"># Array containing the size of every series. Interfaces.</span>
            <span class="n">len_series_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pandas_rest_layer_points</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pandas_rest_layer_points</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()])</span>

            <span class="c1"># Cumulative length of the series. We add the 0 at the beginning and set the shared value. SHARED</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">len_series_i</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">len_series_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">())</span>

            <span class="c1"># Array containing the size of every series. Foliations.</span>
            <span class="n">len_series_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s1">&#39;order_series&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()])</span>

            <span class="c1"># Cumulative length of the series. We add the 0 at the beginning and set the shared value. SHARED</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">len_series_f</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">len_series_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">())</span>

            <span class="c1"># =========================</span>
            <span class="c1"># Choosing Universal drifts</span>
            <span class="c1"># =========================</span>

            <span class="k">if</span> <span class="n">u_grade</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">u_grade</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">len_series_i</span><span class="p">)</span>
                <span class="n">u_grade</span><span class="p">[</span><span class="n">len_series_i</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span>
                <span class="n">u_grade</span><span class="p">[(</span><span class="n">len_series_i</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">len_series_i</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">u_grade</span><span class="p">)</span>
            <span class="c1"># it seems I have to pass list instead array_like that is weird</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">u_grade_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">u_grade</span><span class="p">))</span>

            <span class="c1"># ================</span>
            <span class="c1"># Prepare Matrices</span>
            <span class="c1"># ================</span>
            <span class="c1"># Rest layers matrix # PYTHON VAR</span>
            <span class="n">rest_layer_points</span> <span class="o">=</span> <span class="n">pandas_rest_layer_points</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

            <span class="c1"># TODO delete</span>
            <span class="c1"># -DEP- Again i was just a check point</span>
            <span class="c1"># self.rest_layer_points = rest_layer_points</span>

            <span class="c1"># Ref layers matrix #VAR</span>
            <span class="c1"># Calculation of the ref matrix and tile. Iloc works with the row number</span>
            <span class="c1"># Here we extract the reference points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pandas_ref_layer_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ref_position</span><span class="p">]</span><span class="c1">#.apply(</span>
              <span class="c1">#  lambda x: np.repeat(x, len_interfaces - 1))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">len_interfaces</span> <span class="o">=</span> <span class="n">len_interfaces</span>


            <span class="n">pandas_ref_layer_points_rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pandas_ref_layer_points</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">len_interfaces</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">ref_layer_points</span> <span class="o">=</span> <span class="n">pandas_ref_layer_points_rep</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

            <span class="c1"># -DEP- was just a check point</span>
            <span class="c1"># self.ref_layer_points = ref_layer_points</span>

            <span class="c1"># Check no reference points in rest points (at least in coor x)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">ref_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="n">rest_layer_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> \
                <span class="s1">&#39;A reference point is in the rest list point. Check you do &#39;</span> \
                <span class="s1">&#39;not have duplicated values in your dataframes&#39;</span>

            <span class="c1"># Foliations, this ones I tile them inside theano. PYTHON VAR</span>
            <span class="n">dips_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">foliations</span><span class="p">[[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
            <span class="n">dip_angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;dip&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
            <span class="n">azimuth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;azimuth&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
            <span class="n">polarity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">foliations</span><span class="p">[</span><span class="s2">&quot;polarity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

            <span class="c1"># Set all in a list casting them in the chosen dtype</span>
            <span class="n">idl</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">](</span><span class="n">xs</span><span class="p">)</span> <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="p">(</span><span class="n">dips_position</span><span class="p">,</span> <span class="n">dip_angles</span><span class="p">,</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">polarity</span><span class="p">,</span>
                   <span class="n">ref_layer_points</span><span class="p">,</span> <span class="n">rest_layer_points</span><span class="p">)]</span>

            <span class="k">return</span> <span class="n">idl</span>

        <span class="k">def</span> <span class="nf">set_theano_shared_parameteres</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Here we create most of the kriging parameters. The user can pass them as kwargs otherwise we pick the</span>
<span class="sd">            default values from the DataManagement info. The share variables are set in place. All the parameters here</span>
<span class="sd">            are independent of the input data so this function only has to be called if you change the extent or grid or</span>
<span class="sd">            if you want to change one the kriging parameters.</span>
<span class="sd">            Args:</span>
<span class="sd">                _data_rescaled: DataManagement object</span>
<span class="sd">                _grid_rescaled: Grid object</span>
<span class="sd">            Keyword Args:</span>
<span class="sd">                u_grade (int): Drift grade. Default to 2.</span>
<span class="sd">                range_var (float): Range of the variogram. Default 3D diagonal of the extent</span>
<span class="sd">                c_o (float): Covariance at lag 0. Default range_var ** 2 / 14 / 3. See my paper when I write it</span>
<span class="sd">                nugget_effect (flaot): Nugget effect of foliations. Default to 0.01</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Kwargs</span>
            <span class="n">u_grade</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;u_grade&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">range_var</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;range_var&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">c_o</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;c_o&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">nugget_effect</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nugget_effect&#39;</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
            <span class="c1"># DEP</span>
           <span class="c1"># compute_all = kwargs.get(&#39;compute_all&#39;, True)</span>

            <span class="c1"># -DEP- Now I rescale the data so we do not need this</span>
            <span class="c1"># rescaling_factor = kwargs.get(&#39;rescaling_factor&#39;, None)</span>

            <span class="c1"># Default range</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">range_var</span><span class="p">:</span>
                <span class="n">range_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>


            <span class="c1"># Default covariance at 0</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">c_o</span><span class="p">:</span>
                <span class="n">c_o</span> <span class="o">=</span> <span class="n">range_var</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">14</span> <span class="o">/</span> <span class="mi">3</span>

            <span class="c1"># Asserting that the drift grade is in this range</span>
           <span class="c1"># assert (0 &lt;= all(u_grade) &lt;= 2)</span>

            <span class="c1"># Creating the drift matrix. TODO find the official name of this matrix?</span>
            <span class="n">_universal_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_scaled</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_scaled</span><span class="o">.</span><span class="n">grid</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_grid_scaled</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_scaled</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_grid_scaled</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_scaled</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_grid_scaled</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_scaled</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]))</span>

            <span class="c1"># Setting shared variables</span>
            <span class="c1"># Range</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">a_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">](</span><span class="n">range_var</span><span class="p">))</span>
            <span class="c1"># Covariance at 0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">c_o_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">](</span><span class="n">c_o</span><span class="p">))</span>
            <span class="c1"># Foliations nugget effect</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">nugget_effect_grad_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">](</span><span class="n">nugget_effect</span><span class="p">))</span>

            <span class="c1"># TODO change the drift to the same style I have the faults so I do not need to do this</span>
            <span class="c1"># # Drift grade</span>
            <span class="c1"># if u_grade == 0:</span>
            <span class="c1">#     self.tg.u_grade_T.set_value(u_grade)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     self.tg.u_grade_T.set_value(u_grade)</span>
                <span class="c1"># TODO: To be sure what is the mathematical meaning of this -&gt; It seems that nothing</span>
                <span class="c1"># TODO Deprecated</span>
                <span class="c1"># self.tg.c_resc.set_value(1)</span>

            <span class="c1"># Just grid. I add a small number to avoid problems with the origin point</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">grid_val_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid_scaled</span><span class="o">.</span><span class="n">grid</span> <span class="o">+</span> <span class="mf">10e-6</span><span class="p">))</span>
            <span class="c1"># Universal grid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">universal_grid_matrix_T</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cast</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">](</span><span class="n">_universal_matrix</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">))</span>

            <span class="c1"># Initialization of the block model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">final_block</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_scaled</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">))</span>

            <span class="c1"># Initialization of the boolean array that represent the areas of the block model to be computed in the</span>
            <span class="c1"># following series</span>
            <span class="c1">#self.tg.yet_simulated.set_value(np.ones((_grid_rescaled.grid.shape[0]), dtype=&#39;int&#39;))</span>

            <span class="c1"># Unique number assigned to each lithology</span>
            <span class="c1">#self.tg.n_formation.set_value(np.insert(_data_rescaled.interfaces[&#39;formation number&#39;].unique(),</span>
            <span class="c1">#                                        0, 0)[::-1])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">n_formation</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">interfaces</span><span class="p">[</span><span class="s1">&#39;formation number&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>

            <span class="c1"># Number of formations per series. The function is not pretty but the result is quite clear</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;order_series&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">formation</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">final_potential_field_at_formations</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="o">.</span><span class="n">get_value</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                                           <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">final_potential_field_at_faults</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="o">.</span><span class="n">get_value</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                         <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">get_kriging_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="c1"># range</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">a_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">a_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_scaled</span><span class="o">.</span><span class="n">rescaling_factor</span><span class="p">)</span>
            <span class="c1"># Number of drift equations</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of drift equations&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">u_grade_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
            <span class="c1"># Covariance at 0</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Covariance at 0&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">c_o_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
            <span class="c1"># Foliations nugget effect</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Foliations nugget effect&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">nugget_effect_grad_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Input data shapes</span>

                <span class="c1"># Lenght of the interfaces series</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Length of the interfaces series&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">len_series_i</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
                <span class="c1"># Length of the foliations series</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Length of the foliations series&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">len_series_f</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
                <span class="c1"># Number of formation</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of formations&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">n_formation</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
                <span class="c1"># Number of formations per series</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of formations per series&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">n_formations_per_serie</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
                <span class="c1"># Number of points per formation</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of points per formation (rest)&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tg</span><span class="o">.</span><span class="n">number_of_points_per_formation_T</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Welcome to GeMpy’s documentation!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Kriging.html">Kriging structure of the <em>Potential field method</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code.html">Code</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Miguel de la Varga, CGR-Aachen Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>